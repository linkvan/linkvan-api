{
  "openapi": "3.0.3",
  "info": {
    "title": "Opendatasoft's Explore API Reference Documentation",
    "version": "v2.1",
    "description": "# Introduction\n\nWelcome to the Opendatasoft Explore API!\n\nThe Opendatasoft Explore API v2 is organized around REST. It provides access\nto all the data available through the platform in a coherent, hierarchical way.\n\nIf you want to learn more about how to make the most out of the API, we recommend\nreading the article [Introduction to API explore](https://userguide.opendatasoft.com/l/fr/article/b3dyxp1acz-une-introduction-l-api-explore). This article will provide you\nwith a comprehensive overview of the API's capabilities and guide you through\nthe process of accessing and manipulating data.\n\n- Only the HTTP `GET` method is supported.\n- All API endpoints return JSON.\n- Endpoints are organized in a hierarchical way describing the relative\n  relationship between objects.\n- All responses contain a list of links allowing easy and relevant\n  navigation through the API endpoints.\n- All endpoints use the Opendatasoft Query Language (ODSQL). This means\n  that most of the time, parameters work the same way for all endpoints.\n- While the `records` endpoint is subject to a [limited number of returned records](https://help.opendatasoft.com/apis/ods-explore-v2/#tag/Dataset/operation/getRecords), the `exports` endpoint has no limitations.\n\n## Status\n\nThe v2.1 version is stable and production ready: no breaking change will be introduced in the future, following our [versioning policy](#section/Versioning).\n\n\n## v2.1 Changelog\n\nFollowing our [versioning policy](#section/Versioning), some changes have been introduced in the 2.1 version of the Explore API. Some of them may not be backward compatible with the previous version:\n\n- the `group_by` clause is now available [on export endpoints](#tag/Dataset/operation/exportRecords)\n- the XLSX export format replaces the old XLS format\n- full text searches have been reworked:\n  - the [search()](#section/ODSQL-predicates/search()) function has been changed,\n  - two new functions are available: [suggest()](#section/ODSQL-predicates/suggest()) and [startswith()](#section/ODSQL-predicates/startswith())\n- date functions ([year()](#section/ODSQL-functions/year()), [month()](#section/ODSQL-functions/month()), [day()](#section/ODSQL-functions/day()), [hour()](#section/ODSQL-functions/hour()), [minute()](#section/ODSQL-functions/minute()), [second()](#section/ODSQL-functions/second())) now return integers, instead of strings\n- [grouping by geo fields](#section/Opendatasoft-Query-Language-(ODSQL)/Group-by-clause) is now deprecated and the `geo_cluster()` grouping function should be used instead\n- in a `group_by`, [null values are now grouped](#section/Opendatasoft-Query-Language-(ODSQL)/Language-elements)\n- [date aggregation keys are formatted as isoformat dates](#section/Opendatasoft-Query-Language-(ODSQL)/Group-by-clause), previously as timestamps\n- [CSV exports](#tag/Dataset/operation/exportRecordsCSV) output a Byte Marker Order (BOM) character by default\n- [GPX exports](#tag/Dataset/operation/exportRecordsGPX) use `<extension>` instead of `<desc>` by default to export attributes\n- datetimes in GeojSON exports are now output as isoformat strings, they were previously output as integer timestamps\n- geometry functions have been renamed (old function names are still available):\n  - `distance()` becomes [`within_distance()`](#section/ODSQL-predicates/within_distance())\n  - `geometry(geom1, geom2, INTERSECTS)` becomes [`intersects()`](#section/ODSQL-predicates/intersects())\n  - `geometry(geom1, geom2, DISJOINT)` becomes [`disjoint()`](#section/ODSQL-predicates/disjoint())\n  - `geometry(geom1, geom2, WITHIN)` becomes [`within()`](#section/ODSQL-predicates/within())\n\nRegarding endpoints:\n- `/api/explore/v2.0/<source>/datasets/<dataset_id>/aggregates` and `/api/explore/v2.0/<source>/datasets/<dataset_id>/query` are not available anymore in v2.1. Their functionalities have been merged into the unique \"records\" endpoint (`/api/explore/v2.0/<source>/datasets/<dataset_id>/records`),\n- The output schemas of the following endpoints have been changed:\n  - [`/api/explore/v2.1/<source>/datasets`](#tag/Catalog/operation/getDatasets)\n  - [`/api/explore/v2.1/<source>/datasets/<dataset_id>`](#tag/Catalog/operation/getDataset)\n  - [`/api/explore/v2.1/<source>/datasets/<dataset_id>/records`](#tag/Dataset/operation/getRecords)\n  - [`/api/explore/v2.1/<source>/datasets/<dataset_id>/records/<record_id>`](#tag/Dataset/operation/getRecord)\n\n\n## Base URL\n\nThe Explore API is accessed using a base URL that is specific to a domain. In\nthe examples provided in the documentation, we use the domain\n<http://documentation-resources.opendatasoft.com>.\n\nURL paths start with `/api/explore/v2.1`. A path to a resource looks like this:\n`https://<domain>/api/explore/v2.1/<resource>`.\n\n# Getting Started\n\nTo try out the Explore API, you'll get the first two records from a dataset that includes\nmonthly prices for gold.\n\nYou'll get data from a portal providing public access to data.\nSo, you don't need an account or an API key.\n\n## Step 1: Find dataset information\n\nFor this example, you will use the [GET records endpoint](#operation/getRecords) to list records from a dataset.\nSo, you need the dataset identifier and the name of the field that stores the dates to build your request.\n\n1. Open a browser and go to the desired domain:\n   `https://documentation-resources.opendatasoft.com/explore`.\n\n   The `explore` page lists all datasets on the domain.\n\n2. Click the desired dataset.\n\nFor this example, click \"Gold Prices\".\n\n3. Open the **Information** tab and check the **dataset identifier**.\n\nIn this example, the dataset identifier is `gold-prices`.\n\n## Step 2: Build your ODSQL query\n\nIn this example, you just want to retrieve the first set of two dataset records.\nThe records returned by the request are grouped into pages. Pages are limited in size according to the number of records per page as specified by the `limit` parameter.\n\n1. To determine how many records to retrieve, start the query with a `limit` parameter. Since you only want to retrieve the first two records, use `2` as the parameter value.\n2. To determine the specific page of data to be returned, use an `offset` parameter. Since you only want to retrieve the first set of two records, use `0` as the parameter value or keep it unspecified, since `0` is the default value.\n3. Put all the elements together.\n\nThe complete query is `limit=2&offset=0`.\n\n## Step 3: Build your request\n\nTo retrieve data using the Explore API, use the `GET` HTTP method.\n\nThe path to a resource is made up of the following elements:\n\n- A domain: in this example, query the Explore API on the `documentation-resources.opendatasoft.com` domain.\n- A resource: from the domain's `catalog`, retrieve the `records` of the `gold-prices` dataset.\n- A query: use the `select=count(*)&group_by=year(date)` query built in the previous step.\n\nThe complete path is\n`https://documentation-resources.opendatasoft.com/api/explore/v2.1/catalog/datasets/gold-prices/records?limit=2`\n\nYou can access the Explore API using curl or any HTTP client.\n\nTo make a query using curl, open a terminal and paste the following command:\n\n```shell\ncurl -X GET \"https://documentation-resources.opendatasoft.com/api/explore/v2.1/catalog/datasets/gold-prices/records?limit=2\"\n```\n\nThe response should look like this:\n\n```json\n{\n  \"total_count\": 384,\n  \"results\": [\n    {\n      \"date\": \"1988-01\",\n      \"price\": 477.758\n    },\n    {\n      \"date\": \"1988-03\",\n      \"price\": 443.491\n    }\n  ]\n}\n```\n\n`total_count` shows the total number of records returned by the query.\n\nThe `results` array contains the two records returned by the request. In case you use a `group_by`, the `total_count`\nshows the **available** total number of groups returned by the API (with a maximum of 20000).\n\n\nFor example, we can see the first record contains two fields: `date` and `price`.\nGiven the information from the first record, in January 1988 (`1988-01`), the gold price was $477.758 (`477.758`).\n\n## Next steps\n\nRead the [Opendatasoft Query Language\n(ODSQL)](<#section/Opendatasoft-Query-Language-(ODSQL)>) reference documentation. It\nwill help you build queries, search and filter data from Opendatasoft\nportals.\n\n# Authentication\n\nAn authenticated user can be granted access to restricted datasets and\nbenefit from extended quotas for API calls. The API features an\nauthentication mechanism for users to be granted their specific\nauthorizations.\n\nFor the platform to authenticate a user, you need to either:\n\n- be logged in a portal, so a session cookie authenticating your user is\n  passed along your API calls, or\n- provide an API key via the Authorization header or as a query parameter.\n\n## Finding and generating API keys\n\nAPI keys are managed via your user profile page at\n`https://<domain>/account/` or by clicking on your name in the header.\n\nGo to the tab named My API keys to see your existing API keys, revoke them\nand create new ones.\n\n**Note:** By default, every API key authenticates requests as coming from your user,\nwhich means they grant the same rights (yours) to any person using them.\nTherefore, you should not share your keys. For advanced usages, API key\npermissions can be edited using the API key Automation API.\n\n## Providing API keys within requests\n\nIf you try to access a private portal's catalog without being authenticated, the API returns a `401 Unauthorized` error.\n\nAfter generating an API key, you can use it to make authenticated requests. Depending on the permissions granted to the user for which the API key has been created, the JSON response contains only data about the datasets this user can access on the portal.\n\nIt is good practice to pass the API key to the `Authorization` header in the following format:\n\n`Authorization: Apikey <API_KEY>`\n\nAlternatively, you can pass the API key as a query parameter in the following format:\n\n`apikey=<API_KEY>`\n\nReplace `<API_KEY>`with your API key.\n\n**Note:** We recommend passing the API key via a header over in a query parameter because headers are not stored in your browser history or server logs, minimizing the risk of exposure of your API key.\n\n## Using OAuth2 authorization\n\nOpendatasoft implements the OAuth2 authorization flow, allowing third-party\napplication makers to access the data hosted on an Opendatasoft platform on\nbehalf of a user while never having to deal with a password, avoiding any\nuser credential being compromised.\n\nThe Opendatasoft OAuth2 authorization flow is compliant with RFC 6749 and\nuses Bearer Tokens in compliance with RFC 6750.\n\nApplication developers who want to use the Opendatasoft APIs with OAuth2\nmust go through the following steps:\n\n1. Register their application with the Opendatasoft platform.\n2. Request approval from users via an OAuth2 authorization grant.\n3. Request a bearer token that will allow them to query the Opendatasoft\n   platform APIs for a limited amount of time.\n4. Refresh the Bearer Token when it expires.\n\nCurrently, applications are registered on a specific domain and can only\naccess data on this domain.\n\n### Register an application for OAuth2 authentication\n\n1. Go to the My applications tab of your account page on the domain you want\n   to register the application on.\n2. Fill the registration form with the following information:\n   - Application name: the name of the application\n   - Type:\n     - confidential: client password is kept secret from the user and only used from a trusted environment (e.g., a web service, where the client password is stored server-side and never sent to the user)\n     - public: client password is embedded in a client-side application, making it potentially available to the world (e.g., a mobile or desktop application)\n   - Redirection URL: the URL users will be redirected to after they have granted you permission to access their data\n3. Store the resulting client ID and client secret that will be needed to\n   perform the next steps.\n\n### Getting an authorization grant\n\n1. Redirect users to /oauth2/authorize/ with the appropriate query\n   parameters.\n2. The user will then be authenticated in the platform and redirected to a\n   page identifying your application.\n3. From there, the user will review the information you filled in the form\n   described above and the scope of the requested access and grant your\n   application the right to access their data.\n4. Once the user has accepted those terms, they will be redirected to your\n   application's redirection URL with query parameters describing your\n   authorization grant.\n\nThe query parameters you need to supply when redirecting the user are the\nfollowing:\n\n- `client_id`: the client ID you were given during registration\n- `redirect_uri`: the redirect URI you provided during registration\n- `response_type`: this should always be set to code\n- `scopes` (optional): a list of space-separated requested scopes.\n  Currently, only `all` is supported.\n- `state` (optional): a random string of your choice\n\nThe state parameter is not mandatory, but providing one is recommended for\nsecurity reasons to verify the returned value provided in the authorization\ngrant redirect.\n\n> Example of a call to `/oauth2/authorize/`:\n\n```http\nGET /oauth2/authorize/?\nclient_id=123456789&\nredirect_uri=https://example.com&\nresponse_type=code&\nstate=ilovedata&\nscope=all HTTP/1.1\n```\n\nThe authorization grant redirect will have these values:\n\n- `code`: a 30-characters-long authorization code\n- `state`: the state passed in the request described above\n\nThe 30-character authorization code must now be converted into a bearer\ntoken within 1 hour before expiring.\n\nHere is an example of redirection following a successful authorization:\n\n```http\nHTTP/1.0 302 FOUND\n\nLocation:\nhttps://example.com?state=ilovedata&code=gKnAQc2yIfdz2mY25xxgpTY2uyG5Sv\n\n```\n\n### Converting an authorization grant to a bearer token\n\nTo receive a bearer token, convert the previously obtained authorization\ngrant via a POST request to `/oauth2/token/` with the following parameters:\n\n- `client_id`: the client ID you were given during registration\n- `client_secret`: the client secret you were given during registration\n- `redirect_uri`: the redirect URI you provided during registration\n- `grant_type`: this should always be set to `authorization_code`\n- `code`: the 30-character authorization code received as an authorization\n  grant\n- `scopes` _(optional)_: a list of space-separated requested scopes.\n  Currently, only `all` is supported.\n- `state` _(optional)_: a random string of your choice\n\nExample call to `/oauth2/token/`:\n\n```http\nPOST /oauth2/token/ HTTP/1.1\n\nclient_id=cid&\nclient_secret=csc&\ngrant_type=authorization_code&\ncode=GokshWxRFXmW0MaLHkDv5HrG6wieGs&\nscopes=all&\nredirect_uri=https://example.com&\nstate=ilovedata\n```\n\nAlternative call with an `Authorization` header:\n\n```http\nPOST /oauth2/token/ HTTP/1.1\n\nAuthorization: Basic Y2lkOmNzYw==\n\ngrant_type=authorization_code&\ncode=GokshWxRFXmW0MaLHkDv5HrG6wieGs&\nscopes=all&\nredirect_uri=https://example.com&state=ilovedata\n```\n\nAlternatively, you can pass your client ID and client secret through the\nAuthorization header\n\nThe response to this request is a JSON representation of a bearer token,\nwhich contains the following values:\n\n- `access_token`: the token you can use to access the user's data.\n- `expires_in`: the number of seconds before token expiration\n- `token_type`: the type of the token. It will always be `Bearer`\n- `state`: the state passed in the request described above\n- `scope`: the list of scopes of this authorization code\n- `refresh_token`: a refresh token that can be used to renew this bearer\n  token when expired\n\n> Unlike the access token, which can be used any number of times until\n> expiration, the refresh token doesn't expire but can only be used once.\n\nExample response for a bearer token request:\n\n```http\nHTTP/1.0 200 OK\n\nContent-Type: application/json\n```\n\n```json\n{\n  \"access_token\": \"9kxoTUYvSxnAiMpv008NBqRiqk5xWt\",\n  \"expires_in\": 3600,\n  \"token_type\": \"Bearer\",\n  \"state\": \"ilovedata\",\n  \"scope\": \"all\",\n  \"refresh_token\": \"jFfDUcsK9zzNMs1zwczzJxGrimPtmf\"\n}\n```\n\n### Using the bearer token\n\nThe bearer token can be passed along requests for authentication in three\ndifferent ways:\n\n- as a query parameter of the request\n\n```http\nGET /api/end/point?access_token=9kxoTUYvSxnAiMpv008NBqRiqk5xWt HTTP/1.1\n```\n\n- in the request's `Authorization` header\n\n```http\nGET /api/end/point HTTP/1.1\n\nAuthorization: Bearer 9kxoTUYvSxnAiMpv008NBqRiqk5xWt\n```\n\n- in the request body\n\n```http\nGET /api/end/point HTTP/1.1\n\naccess_token=9kxoTUYvSxnAiMpv008NBqRiqk5xWt\n```\n\n### Refreshing a bearer token\n\nTo refresh an expired bearer token, send a request to the `/oauth2/token/`\nendpoint, with the following query parameters:\n\n- `client_id`: the client ID you were given during registration\n- `client_secret`: the client secret you were given during registration\n- `refresh_token`: the refresh token returned in the bearer token response\n- `grant_type`: this should always be set to `refresh_token`\n- `scopes`: a list of space-separated requested scopes. Currently, only\n  `all` is supported.\n- `state` _(optional)_: a random string of your choice\n\nThe response to this request is identical to the bearer token response.\n\nExample token refresh call:\n\n```http\nPOST /oauth2/token/ HTTP/1.1\n\nclient_id=cid&\nclient_secret=csc&\ngrant_type=refresh_token&\nrefresh_token=jFfDUcsK9zzNMs1zwczzJxGrimPtmf&\nscopes=all&\nredirect_uri=https://example.com&\nstate=ilovedata\n```\n\n# Opendatasoft Query Language (ODSQL)\n\nFiltering features are built in the core of the Opendatasoft API engine.\n\nThe Opendatasoft Query Language (ODSQL) makes it possible to express complex\nqueries as a filtering context for datasets or records and build\naggregations or computed fields.\n\nA given filtering context can simply be copied from one API to\nanother. For example, it is possible to build a user interface that allows\nthe user to visually select the records they are interested in, using\nfull-text search, facets, and geo-filtering. Then, it allows them to\ndownload these records with the same filtering context.\n\nThe ODSQL is split into five different kinds of clauses:\n\n- The [`select` clause](#section/Opendatasoft-Query-Language-(ODSQL)/Select-clause) allows choosing the returned fields, giving them an\n  alias, manipulating them with functions like count, sum, min, max, etc.\n- The [`where` clause](#section/Opendatasoft-Query-Language-(ODSQL)/Where-clause) acts as a filter for the returned datasets or records,\n  thanks to boolean operations, filter functions, arithmetic expressions, etc.\n- The [`group by` clause](#section/Opendatasoft-Query-Language-(ODSQL)/Group-by-clause) allows aggregating rows together based on fields,\n  numeric ranges, or dates.\n- The [`order by` and `limit` clauses](#section/Opendatasoft-Query-Language-(ODSQL)/Order-by-clause) allow choosing the order and quantity\n  of rows received as a response.\n\nThese clauses are used as parameters in the Explore API v2 for searching,\naggregating, and exporting datasets and records. Depending on the used\nendpoint, some features of the query language are available or not in the\nrequest.\n\n**Note:** the whole query language is case insensitive, and spaces are optional. In this documentation, the uppercase is used for language keywords, only for clarity purposes.\n\n## Language elements\n\nODSQL clauses are composed of basic language elements. These can either be\n[field names or aliases](#field-names), [literals](#literals-in-odsql-clauses) or [reserved keywords](#reserved-keywords-in-odsql-clauses).\n\n### Field names\n\nA field name is made of alphanumeric characters and underscores and refers to a field of a dataset or to a dynamically created field that only exists during the query (a.k.a. an alias).\n\n**Note:** if a field name contains only numbers or is a keyword, it must be enclosed in back quotes.\n\n> Examples of a field names:\n\n```sql\nmy_field > 10  -- my_field is a field name\n\n`12` > 10  -- without back quotes, 12 would be considered a numeric literal\n\n`and`: \"value\" -- AND is a keyword, `and` represents a field name then\n```\n\n### Literals in ODSQL clauses\n\nLiterals are fixed values of a specific type and can be used in comparison, assignments, or functions.\n\nThere are 6 types of literal:\n\n- string\n- numeric\n- date\n- boolean\n- geometry\n- null\n\n#### String literal\n\nA string literal is a literal enclosed in either single or double quotes.\n\n> Examples of a string literal:\n\n```sql\n\"Word\"\n\n\"Multiple words\"\n\n'Using single quotes'\n```\n\n**Note:** `\\` (backslash) character can be used to escape special characters. For example to escape a single quote: `'Don\\'t worry'`.\n\n#### Numeric literal\n\nA numeric literal is either an integer or a decimal value. It is not enclosed in quotes.\n\n> Examples of numeric literals:\n\n```sql\n100\n\n5.8\n\nmy_field > 108.7\n```\n\n#### Date literal\n\nA date literal is defined with a `date` keyword followed by a valid date\nformat enclosed in single quotes.\n\nA valid date can be:\n\n- an [ISO 8601 date](https://en.wikipedia.org/wiki/ISO_8601), or\n- a slash-separated date in the YYYY/MM/DD (year/month/day) format.\n\n> Examples of a date literal:\n\n```sql\ndate'2017-04-03T08:02'\n\ndate'2018/04/01'\n```\n\n#### Boolean literal\n\nA boolean literal can either be a `TRUE` or a `FALSE` keyword (case\ninsensitive). It should be used in boolean filters.\n\n> Example of a boolean literal:\n\n```sql\nmy_boolean_field is TRUE\n\nmy_boolean_field: FALSE\n```\n\n#### Geometry literal\n\nA geometry literal is defined with a `geom` keyword followed by a valid\ngeometry expression enclosed in single quotes.\n\nSupported geometry expressions are:\n\n- [WKT/WKB](https://en.wikipedia.org/wiki/Well-known_text)\n- [GeoJSON geometry](https://en.wikipedia.org/wiki/GeoJSON)\n\n> Example of a geometry literal:\n\n```sql\nwithin_distance(my_geo_field, geom'POINT(1 1)', 10km)\n\ngeometry(my_geo_field, geom'{\"type\": \"Polygon\",\"coordinates\":[[[100.0,\n0.0],[101.0, 0.0],[101.0, 1.0],[100.0, 1.0],[100.0,0.0]]]}')\n```\n#### Null literal\n\nThe `null` literal (case insensitive) is used to represent the absence of a value.\n\nIt is present in the [is null filter](#section/ODSQL-predicates/IS-NULL-filter) to test whether a field has a value or not.\n\n### Reserved keywords in ODSQL clauses\n\nReserved keywords can be used inside clauses for building ODSQL expressions.\n\nWhen used in a clause as a field literal, the reserved keyword must be\nescaped with back quotes.\n\nList of reserved keywords:\n\n- and\n- as\n- asc\n- avg\n- by\n- count\n- date_format\n- day\n- dayofweek\n- desc\n- distinct\n- equi\n- false\n- group\n- hour\n- ifnull\n- or\n- limit\n- lower\n- max\n- millisecond\n- min\n- minute\n- month\n- not\n- null\n- quarter\n- range\n- search\n- second\n- select\n- sum\n- top\n- true\n- upper\n- where\n- year\n\nFor example, `not` is a reserved keyword and must be escaped with back quotes if referred to as a field literal:\n\n```sql\nmy_field_literal is not true -- my_field_literal is not a reserved keyword, there's no need to escape it\n\n`not` is not true -- not is a reserved keyword and must be escaped\n```\n\n### Handling null values\n\nA `null` value in a dataset is used when the value in a field is unknown or missing. It means that there is no data for a field in a record.\n\nEach clause behaves differently to handle null values:\n\n- When selecting a field in a `select` clause, null values are represented as `null`.\n- When filtering with a `where` clause, a comparison involving at least one null value is false, meaning that null values are filtered out of the result.\n- When grouping with a `group_by` clause, no group exists for null values in v2.0, a null group do exist starting with v2.1\n- When sorting with an `order_by` clause, null values come after all other values, regardless of the sorting direction (i.e., ascending or descending).\n\nDefault handling of null values can be changed by filtering using the [is null filter](#section/ODSQL-predicates/IS-NULL-filter) or replacing null values by an alternative value or expression using the `ifnull` function.\n\n\n## Select clause\n\nThe select clause can be used in records Explore APIs as the parameter `select`.\n\nThe select clause allows:\n\n- choosing the fields that will be returned for each row,\n- transforming fields using arithmetic,\n- renaming fields,\n- adding computed virtual fields to fields, and\n- including or excluding fields based on a pattern.\n\nA select clause is composed of a single select expression or a list of comma-separated expressions.\n\nA select expression can be:\n\n- a field literal,\n- an include/exclude function,\n- an arithmetic expression, or\n- an aggregation function.\n\nExcept for the include/exclude function, a select expression can define a label with the keyword `AS`. This label will be used in the output of the API as `key` for the select expression result.\n\n### Select field names\n\nA select field name is the simplest form of select expression. It takes a field name that must be returned in the result.\nIt also accepts the special character `*` to select all fields (it is the default behavior).\n\nIf a select expression is used in conjunction with a `group by` clause, the selected field name must be in the `group by` clause.\n\n> Examples of a select field literal:\n\n```sql\n*                           -- Select all fields\n\nfield1, field2, field3      -- Only select field1, field2, and field3\n\nfield1 AS my_field, field2  -- Renaming field1 as my_field and select field2\n```\n\n\n### Select aggregation\n\nLike in the SQL language, a `select` can also express an aggregation expression.\n\nThe following aggregation functions are available:\n\n- [avg (average)](#section/ODSQL-aggregate-functions/avg())\n- [count](#section/ODSQL-aggregate-functions/count())\n- [count distinct](#section/ODSQL-aggregate-functions/count(distinct))\n- [envelope](#section/ODSQL-aggregate-functions/envelope())\n- [max (maximum)](#section/ODSQL-aggregate-functions/max())\n- [median](#section/ODSQL-aggregate-functions/median())\n- [min (minimum)](#section/ODSQL-aggregate-functions/min())\n- [percentile](#section/ODSQL-aggregate-functions/percentile())\n- [sum](#section/ODSQL-aggregate-functions/sum())\n\n> Examples of an aggregation expression:\n\n```sql\nSUM(population) as sum_population -- Will compute the sum of all values for the field `population` returned as sum_population\n\nCOUNT(*) -- Return number of elements\n```\n\n## Where clause\n\nThe where clause can be used in the whole Explore API as the parameter `where`.\n\nThe where clause allows one to filter rows with a combination of boolean expressions.\n\nA where expression can be:\n\n- a search query\n- a filter function\n- a comparison filter\n- an equality filter\n\nWhere expressions can be combined with [boolean operators](#boolean-operators) and grouped via parenthesis.\n\n> Example of a where clause with boolean operators:\n```sql\nmy_numeric_field > 10 and my_text_field like \"paris\" or within_distance(my_geo_field, geom'POINT(1 1)', 1km)\n```\n> This where clause filters results where numeric_field > 10 and (my_text_field contains the word `paris` or distance between my_geo_field and the point with 1,1 as lat,lon is under 1 kilometer)\n\n**Note**: it is generally possible to use multiple `where` clauses on an API endpoint. They are combined with a boolean `AND` in that case.\n\n### Boolean operators\n\nWhere expressions can use boolean operators to express boolean filter.\n\nThere are 3 different boolean operations:\n\n- `AND`: results must match left and right expressions\n- `OR`: results must match left or right expression\n- `NOT`: inverses the next expression\n\n`AND` has precedence over the `OR` operator. It means that, in the expression `a or b and c`, the sub-expression `b and c` is interpreted and executed first. It can also be written with parenthesis: `a or (b and c)`.\n\nIn order to change operator precedence, it is possible to use parenthesis in the expression. To give precedence to the `OR` operator, the above expression can be written `(a or b) and c`.\n\n> Examples of a boolean operator:\n\n```sql\nmy_boolean_field OR my_numeric_field > 50 and my_date_field > date'1972'\n-- Results can have my_boolean_field to true. They can also have my_numeric_field greater than 50 and my_date_field older than 1972\n\n(my_boolean_field OR my_numeric_field > 50) and my_date_field > date'1972'\n-- Results must have my_date_field older than 1972. They also must have my_boolean_field to true or my_numeric_field greater than 50\n```\n\n### Search query filter\n\nFilter search queries are queries that donâ€™t refer to fields. They only contain quoted strings and boolean operators. Filter search queries perform full-text searches on all visible fields of each record and return matching rows.\n\nIf the string contains more than one word, the query will be an `AND` query on each tokenized word.\n\n> Examples of a search query:\n\n```sql\n\"tree\"\n\n\"tree\" AND \"flower\"\n\n\"tree\" OR \"car\"\n\nNOT \"dog\"\n\n\"dog\" AND NOT \"cat\"\n```\n\n> Examples of a search query with multiple words:\n\n```sql\n\"film\"           -- returns results that contain film\n\n\"action movies\"  -- returns results that contain action and movies.\n```\n\n### Filter functions\n\nFilter functions are built-in functions that can be used in a `where` clause.\n\nAvailable filter functions are:\n\n- [`search` function](#section/ODSQL-predicates/search()), to perform a full-text search\n- [`suggest` function](#section/ODSQL-predicates/suggest())\n- [`startswith` function](#section/ODSQL-predicates/startswith())\n- [`in_bbox` function](#section/ODSQL-predicates/in_bbox()), to filter in a geographical area defined by a bounding box\n- [`within_distance` function](#section/ODSQL-predicates/within_distance()), to filter in a geographical area defined by a circle\n- [`intersects`](#section/ODSQL-predicates/intersects()), [`disjoint`](#section/ODSQL-predicates/disjoint()) and [`within`](#section/ODSQL-predicates/within()) to filter in a geographical area defined by a geometry\n\n### Comparison operators\n\nThree types of comparison operators can be used in a `where` clause:\n\n- [text comparison operators](#section/ODSQL-predicates/Text-comparison-operators)\n- [numeric comparison operators](#section/ODSQL-predicates/Numeric-comparison-operators)\n- [date comparison operators](#section/ODSQL-predicates/Date-comparison-operators)\n\n## Group by clause\n\nThe group by clause can be used in the Explore API as the parameter `group_by`.\n\nThe group by clause creates groups from data depending on a group by expression. Groups of data cannot be returned directly and aggregation functions in the `select` clause have to be used to \"summarize\" and return a value for each group. An operation of \"aggregation\" can then be described by two parts: the `group_by` part that make groups of rows of data from a specific criterion and an aggregation function in the `select` clause to reduce each group to a row.\n\nA group by clause can contain:\n\n- a single group by expression, or\n- a list of comma-separated group by expressions.\n\nLike select expressions, a group by expression can have an `AS` statement to give it a label.\n\nA group by expression can be:\n\n- empty,\n- a field,\n- [static ranges](#section/ODSQL-grouping-functions/range()-group-by-static-ranges),\n- [ranges of equal widths](#section/ODSQL-grouping-functions/range()-group-by-ranges-of-equal-widths),\n- the result of a function applied on a field value (e.g. a date function, or a date format)\n\n> Example of a simple group by expression with a label:\n\n```sql\ngroup_by=my_field as myfield\n```\n\n> Example of multiple group by expressions with a label:\n\n```sql\ngroup_by=my_field1,my_field2 as my_field\n```\n\n### Empty group by\n\nWhen no `group_by` part is expressed, rows of data are implicitly grouped into an sole group and aggregation functions are computed on the whole set of records.\n\n### Group by field\n\nA group by field expression allows the grouping of specified field values. It creates a group for each different field value.\n\n**Format:** `group_by=<field_literal>`\n\n> Example of a simple group by field expression\n\n```sql\ngroup_by=my_field\n```\n\n**Note:**\n- Starting with v2.1, grouping by geopoint or geoshape fields is not supported directly anymore. Please use the [geo_cluster() grouping function](#section/ODSQL-grouping-functions/geo_cluster()) to make groups out of geo points.\n- Starting with v2.1, grouping by a date field now formats the key of each group as a string representing the ISO formatting of the date, when it was an integer timestamp in v2.0\n\n## Order by clause\n\nThe order by clause can be used to sort rows returned by a query.\n\nThe parameter `order_by` adds an order by clause to an API query.\nIt accepts a list of comma-separated expressions followed by a direction:\n\n- ASC for ascending\n- DESC for descending\n\n**Format:** `order_by = expression [ ASC | DESC ], ...`\n\nAn order by expression can be:\n\n- a field\n- an aggregation function\n- [a `random` function](#section/ODSQL-functions/random())\n\nThe direction, if not specified, is ASC (ascending) by default.\nThe random sorting will circumvent the default direction.\n\n**Note:** when ordering by both aggregations and fields, the aggregation order must be at the head of the list. For example, `order_by = avg(age), gender works`, but `order_by = gender, avg(age)` returns an error.\n\n> Examples of an order by clause\n\n```sql\ngroup_by=city & order_by=city ASC -- Order cities alphabetically\n\ngroup_by=city & order_by=count(*) DESC -- Order each city by its number of records\n\nselect=count(*) as population_count & group_by=city  & order_by=population_count DESC -- Order each city by its number of records, using a label\n\ngroup_by=city, year(birth_date) as birth_year & order_by=city DESC, birth_year ASC -- Order by city and then by year of birth\n```\n\n# ODSQL functions\n\n## length()\n\n**Syntax:** `length(<text_literal>|<text_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`\n\nReturns the string length of its parameter, i.e. the number of characters that composes the string.\n\n## now()\n\n**Syntax:** `now(<optional_named_parameters>)`\n\n**Returned type:** `datetime`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`\n\n### Parameters to the now() function\n\n> Examples, assuming the current date time is 2021-05-06 12:34:55.450500+00:00, which is a Thursday\n```sql\nnow() -- Returns '2021-05-06T12:34:55.450500+00:00'\nnow(year=2000) -- Sets the year component to return '2000-05-06T12:34:55.450500+00:00'\nnow(years=-1) -- Sets the year to one year ago which is '2020-05-06T12:34:55.450500+00:00'\nnow(year=2001, months=-1) -- Sets the year to 2001 and subtract 1 month to return '2000-04-06T12:34:55.450500+00:00'\nnow(day=31,month=2) -- Sets the day to 31, then the month to 2. The actual day part is rounded to 28 '2021-02-28T12:34:55.450500+00:00'\nnow(weekday=0) -- Sets the day to the next Monday which is '2021-05-10T12:34:55.450500+00:00'\nnow(mondays=+1) -- Sets the day to the next Monday which is also '2021-05-10T12:34:55.450500+00:00'\nnow(mondays=-1) -- Sets the day to the previous Monday which is '2021-05-03T12:34:55.450500+00:00'\n```\n\nWithout any parameters, the `now()` function returns the current date and time.\n\nThe function may also be called with named parameters to set or modify certain parts of the current date and time.\n\nWith each parameter, an integer value is required, interpreted as an absolute value or as a relative value to a part of the current date and time.\n\nParameter names in their singular form will set a certain part of the current date and time to the given value. Parameter names written in plural will add or subtract the given value to a part of the current date and time.\n\nIf a parameter is used multiple times in the call, only the last one is actually used, the others are ignored.\n\n| Parameter name | Accepted values      | Description                                                                                               |\n| -------------- | -------------------- | --------------------------------------------------------------------------------------------------------- |\n| `year`         | 1 to 9999            | Year component                                                                                            |\n| `years`        | Any integer          | Value to add to or subtract from the year component                                                       |\n| `month`        | 1 to 12              | Month component                                                                                           |\n| `months`       | Any integer          | Value to add to or subtract from the month component, then the year component in case of overflow         |\n| `day`          | Any positive integer | Day component, rounded to the maximum valid day number for the current month                              |\n| `days`         | Any integer          | Value to add to or subtract from the day component, then the month component in case of overflow          |\n| `hour`         | 0 to 23              | Hour component                                                                                            |\n| `hours`        | Any integer          | Value to add to or subtract from the hour component, then the day component in case of overflow           |\n| `minute`       | 0 to 59              | Minute component                                                                                          |\n| `minutes`      | Any integer          | Value to add to or subtract from the minute component, then the hour component in case of overflow        |\n| `second`       | 0 to 59              | Second component                                                                                          |\n| `seconds`      | Any integer          | Value to add to or subtract from the second component, then the minute component in case of overflow      |\n| `microsecond`  | 0 to 999999          | Microsecond component                                                                                     |\n| `microseconds` | Any integer          | Value to add to or subtract from the microsecond component, then the second component in case of overflow |\n| `weekday`      | 0 to 6               | Day of the week, 0 for monday to 6 for sunday                                                             |\n| `mondays`      | Any integer          | Number of Mondays to add to or subtract from the current date                                             |\n| `tuesdays`     | Any integer          | Number of Tuesdays to add to or subtract from the current date                                            |\n| `wednesdays`   | Any integer          | Number of Wednesdays to add to or subtract from the current date                                          |\n| `thursdays`    | Any integer          | Number of Thursdays to add to or subtract from the current date                                           |\n| `fridays`      | Any integer          | Number of Fridays to add to or subtract from the current date                                             |\n| `saturdays`    | Any integer          | Number of Saturdays to add to or subtract from the current date                                           |\n| `sundays`      | Any integer          | Number of Sundays to add to or subtract from the current date                                             |\n\n## year()\n\n**Syntax:** `year(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the year number of a date or datetime as a string.\n\n## month()\n\n**Syntax:** `month(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the month number (between 1 and 12) of a date or datetime as a string.\n\n## day()\n\n**Syntax:** `day(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the day number of the month (between 1 and 31) of a date or datetime as a string.\n\n## hour()\n\n**Syntax:** `hour(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the hour number (between 0 and 23) of a date or datetime as a string.\n\n## minute()\n\n**Syntax:** `minute(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the minute number (between 0 and 59) of a date or datetime as a string.\n\n## second()\n\n**Syntax:** `second(<date_literal>|<date_field>|<datetime_literal>|<datetime_field>)`\n\n**Returned type:** `integer`\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\nReturns the second number (between 0 and 59) of a date or datetime as a string.\n\n## date_format()\n\n**Syntax:** `date_format(<date>, <date_format>)`\n\n**Arguments:**\n\n- `<date>`: a date field,\n- `<date_format>`: a string describing how to format the date (see below)\n\n**Returned type:** `string`.\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\n\n`<date_format>` is a string, where each character or group of characters\nwill be replaced by parts of the date in the returned string.\n\nThe following formats are available for a date format expression:\n\n| Symbol       | Description                                            | Examples |\n| ------------ | ------------------------------------------------------ | -------- |\n| yy or YY     | year on two digits                                     | 20       |\n| yyyy or YYYY | year on four digits                                    | 2020     |\n| xx           | weekyear\\* on two digits                               | 96       |\n| xxxx         | weekyear\\* on four digits                              | 1996     |\n| w            | week of weekyear                                       | 7        |\n| ww           | week of weekyear, left-padded with 0                   | 07       |\n| e            | day of week, as a number, 1 for Monday to 7 for Sunday | 2        |\n| E            | day of week, abbreviated name                          | sun.     |\n| EEEE         | day of week, full name                                 | Sunday   |\n| D            | day of year                                            | 89       |\n| DDD          | day of year, left-padded with 0                        | 089      |\n| M            | month of year                                          | 7        |\n| MM           | month of year, left-padded with 0                      | 07       |\n| MMMM        | month of year, full name                               | July     |\n| d            | day of month                                           | 8        |\n| dd           | day of month, left-padded with 0                       | 08       |\n| H            | hour of day, 0-23                                      | 9        |\n| HH           | hour of day, 00-23, left-padded with 0                 | 09       |\n| m            | minute of hour, 0-59                                   | 13       |\n| mm           | minute of hour, 00-59, left-padded with 0              | 09       |\n| s            | second of minute, 0-59                                 | 13       |\n| ss           | second of minute, 00-59, left-padded with 0            | 09       |\n\n\\*Years and week years differ slightly. For more information, see the\n[definition](https://en.wikipedia.org/wiki/ISO_week_date) of week years.\n\nThe date format can contain free text that won't be interpreted. The free\ntext must be surrounded by single quotes '.\n\nTo insert a single quote in the final string, it must be doubled.\n\nSome special characters can also be used as delimiters between date\ncomponents: `?`, `,`, `.`, `:`, `/` and `-`.\n\n> Examples of a `date_format` function, where `date_field` = '2007-11-20T01:23:45':\n\n```sql\ndate_format(date_field, 'dd/MM/YYYY') -- Returns '20/11/2007'\n\ndate_format(date_field, \"'The date is 'dd/MM/YYYY\") -- Returns 'The date is\n20/11/2007'\n\ndate_format(date_field, \"'The date is '''dd/MM/YYYY''\") -- Returns \"The date\nis '20/11/2007'\"\n\ndate_format(date_field, 'E') -- Returns 'mar.'\n\ndate_format(date_field, 'EEEE') -- Returns 'mardi'\n\ndate_format(date_field, 'H') -- Returns '1'\n\ndate_format(date_field, 'HH') -- Returns '01'\n\ndate_format(date_field, 'yy') -- Returns '07'\n\ndate_format(date_field, 'yyyy') -- Returns '2007'\n\ndate_format(date_field, 'M') -- Returns '11'\n\ndate_format(date_field, 'MM') -- Returns '11'\n```\n\nWhen used in the `where` clause, `date_format` must be compared to string\nvalues.\n\n> Example of a `date_format` function used in a `where` clause:\n\n```sql\nwhere=date_format(date_field, 'dd') = '08'\n```\n\nYou can use the `lang` parameter to force the output language.\n\n## json_format()\n\n**Syntax:** `json_format(<text_field>,[<fallback>[<null>|<text_literal>]])`\n\n**Returned type:** `text` or `json`\n\n**Clause where it can be used:** `select`\n\n**Description:**\n\nFormats the text field into JSON if possible. If the text can be transformed into valid JSON, it returns the formatted JSON string. If the text cannot be transformed into valid JSON, it returns either the fallback value if provided or the original string.\n\n- `<text_field>` (mandatory): A text field to be formatted into JSON. It cannot be multivalued.\n\n- `<fallback>` (optional): A fallback string to return if the text cannot be transformed into valid JSON. If omitted, the original string is returned in case of invalid JSON.\n\n**Note**: On `/exports`, except with the JSON export format, this function returns the original text value.\n\n> Example of a `json_format` function used in a `select` clause:\n\n```sql\nselect=json_format(text_field)\n\nselect=json_format(text_field, 'bad json')\n\nselect=json_format(text_field, null)\n```\n\n## ifnull()\n\n**Syntax:** `ifnull(<expression>, <alternative_expression>)`\n\n**Arguments:**\n\n- `<expression>`: a field or an expression\n- `<alternative_expression>`: an alternative field, expression or literal\n\n**Clauses where it can be used:** `select`, `where`, `order_by`, `group_by`\n\n**Returned type:** the type of `<expression>` when not null\n\n**Returned value:** the result of `<alternative_expression>` if `<expression>` returns a null value. The result of `<expression>` otherwise.\n\nThe returned type of `<expression>` and `<alternative_expression>` should be the same.\n\nFor `group_by` clause, expressions are restricted to fields and literals.\n\n> Examples of `ifnull` function, where `int_field` contains some null values:\n\n```sql\nifnull(int_field, 0) -- value of int_field is 0 for each row that contains a null value\n```\n\n## lower()\n\n**Syntax:** `lower(<text_literal>|<text_field>)`\n\n**Returned type:** `string`\n\n**Clauses where it can be used:** `select`, `where`, `order_by` and `group_by`\n\nReturns a string in lowercase.\n\n> Some examples:\n```sql\nlower('JAZZ') -- returns 'jazz'\n\nlower(text_field) -- returns the lowercase representation of the field\n```\n\n## include() and exclude()\n\n**Syntax:** `include(<field_name_pattern>)`\n\n**Syntax:** `exclude(<field_name_pattern>)`\n\n**Clauses where it can be used:** `select` only\n\nInclude and exclude are functions that accept fields names.\n\nFields listed in an include function are present in the result, whereas fields listed in an exclude function are absent from the result.\n\nFields can contain a wildcard suffix (the `*` character). In that case, the inclusion/exclusion works on all field names beginning with the value preceding the wildcard.\n\n**Note**: `include()` and `exclude()` are pseudo functions: they do not return a value, but are used as a declaration to constrain the list of returned fields.\n\n> Examples of an include/exclude:\n\n```sql\ninclude(pop) -- will only include fields which name is pop\n\nexclude(pop) -- will exclude fields which name is pop\n\ninclude(pop*) -- Will include fields beginning with pop\n```\n\n## Arithmetic operators\n\nAn arithmetic expression accepts simple arithmetic operations. It accepts field names, numeric constants or text values, and scalar functions. More complex arithmetic expressions can be formed by connecting these elements with arithmetic operators:\n\n- `+`: add\n- `-`: subtract\n- `*`: multiply\n- `/`: divide\n\n**Note:** A division by zero returns a null value.\n\nArithmetic operators are only defined on numeric values.\n\n> Examples of arithmetic expressions:\n\n```sql\n2 * population -- the value of the field `population` doubled\n\n\"hello\" -- the constant string \"hello\"\n\nlength(country_name) -- the string length of the field `country_name`\n```\n\n## random()\n\n**Syntax:** `random ( <integer> )`\n\n**Clauses where it can be used:** `order_by` only\n\nThe `<integer>` is the seed of the random function.\nWhen using the random function with one same seed, it will return the same random order each time.\n\n> Examples of an order by random\n\n```sql\ngroup_by=city & order_by=random(1) -- Order cities randomly\n\ngroup_by=city & order_by=random(1) -- Order cities randomly in the exact same order as the first example\n\ngroup_by=city & order_by=random(2) -- Order cities randomly in a different order than the first example\n```\n\n## distance()\n\n**Syntax:** `distance(<geo_field>, <center_geometry>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric\n\n> Examples of a `distance` function:\n\n```sql\ndistance(field_name, GEOM'<geometry>')\n```\n\nThe `distance` function computes arc distance between geo_point field and a point geometry as reference. Distance (in m) can be returned using `select` and/or used to sort records.\n\n## vector_similarity()\n\n**Syntax:** `vector_similarity(\"<search query>\")`\n\n**Clauses where it can be used:** only `order_by`\n\n**Returned type:** float\n\nThis function is able to compute a semantic distance between your search query and the catalog metadata, e.g the titles,\nkeywords, themes and descriptions. It can only be used for a catalog search. The results will be semantically sorted,\ni.e. the first results will have some content where the meaning should be close to your search query. For instance if\nyou search `\"funny kitty\"`, the results should have some content which contains the query terms but also `cats`, `fun`,\n`pets`, etc.\n\n> Examples of a `vector_similarity` function:\n\n```sql\nvector_similarity(\"jazz concerts in nyc\")\n```\n\n\n\n# ODSQL predicates\n\nPredicates are functions that return a boolean value (`true` or `false`). They can be used to filter results in the `where` clause.\n\n## search()\n\n**Syntax:** `search(<text_field>|*, <text_literal>)` where:\n- first parameters are the set of fields on which the search is done:\n  - `*` or empty to search on all visible fields\n  - a subset of field names separated with a comma `,`\n- the string to search for as last parameter\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\nThe `search()` function performs a full-text query on all selected fields of each record and return matching records.\n\nIt is a fuzzy search and a prefix search: `<test_literal>` is first split into terms separated by a space, the first terms are searched for with a certain level of fuziness (see below), and the last term is a prefix search.\nThe level of fuziness for each term depends on the length of the term:\n- for terms with a length > 5, it matches strings with a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) of 2,\n- for terms with a length > 2, it matches strings with a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) of 1\n\nThe matching is **case insensitive**.\n\n> Examples of a `search` function:\n\n```sql\nsearch(title, \"bok of secret\")  -- will match \"THE BOOK OF SECRETS\"\n```\n\n\n## suggest()\n\n**Syntax:** `suggest(<text_field>|*, <text_literal>)` where:\n- first parameters are the set of fields on which the search is done:\n  - `*` or empty to search on all visible fields\n  - a subset of field names separated with a comma `,`\n- the string to search for as last parameter\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `suggest` function:\n\n```sql\nsuggest(*, \"film\")  -- returns results that contain film, films, filmography, etc. in at least one visible field\nsuggest(\"film\")  -- equivalent to the above query\nsearch(title, \"secret\")  -- will match \"THE BOOK OF SECRETS\"\n\nsuggest(text_field, other_text_field, \"film\")  -- same search but in text_field or other_text_field\nsuggest(text_field, \"film\") OR suggest(other_text_field, \"film\") -- equivalent to the above query\n\nsuggest(text_field, \"film\") AND suggest(other_text_field, \"film\") -- returns results that contain film, films, filmography, etc. in both fields\n```\n\nThe `suggest()` function performs a full-text query on all selected fields of each record and return matching records.\nIt is a prefix search: it matches the text fields that contain terms **beginning with** the searched string.\n\nThe matching is **case insensitive**.\n\n**Note:** this function may miss some results that match the prefix when it is used with small prefixes.\n\n## vector_similarity_threshold()\n\n**Syntax:** `vector_similarity_threshold(<text_literal>)` where:\n- the string of your search query as unique parameter\n\n**Clauses where it can be used:** `where` only\n\n**Ony available for the catalog search**. It won't work if you want to use it to filter records from a dataset.\n\nIt can be used to carry out a **semantic search** of your catalog instead of a classic lexical search (based on the term\nand not the meaning). With this function, you can search using a sentence, synonyms, or in languages other than the original language of your catalog.\n\nThis semantic search analyzes only the following asset metadata to compute the similarity score: *title*, *keywords*, *themes* and\n*description*. When the *territory* dataset metadata is available, it can also be used.\n\n**Returned type:** boolean\n\nContrary to the `vector_similarity()` function used within `order_by` which returns all catalog results, this function\ncan automatically compute a semantic score threshold in order to avoid irrelevant assets in your search results. This\n\"threshold method\" is based on the [\"Kneedle\" algorithm](https://dl.acm.org/doi/abs/10.1109/ICDCSW.2011.20) to find the\ninflection point from the semantic scores.\n\nSource: Finding a \"Kneedle\" in a Haystack: Detecting Knee Points in System Behavior, *Satopaa, Ville and Albrecht, Jeannie and Irwin, David and Raghavan, Barath*, 2011, IEEE Computer Society -- https://doi.org/10.1109/ICDCSW.2011.20\n\n> Examples of a `vector_similarity_threshold` function:\n\n```sql\n-- can return results that contain film, movie, pulp fiction, filmography,\n-- or content about other movie directors.\nvector_similarity_threshold(\"quentin tarantino movies\")\n\n-- can also return results in another language, for instance in French or German depending on the portal.\nvector_similarity_threshold(\"content about music & jazz\")\n```\n\n**Note**: The semantic method may generate irrelevant results. This potential inaccuracy is due to several underlying issues:\n  * The vector content may prove insufficient in detail or context to reliably produce accurate results.\n  * A significant challenge is the inherent asymmetry between the concise nature of user search queries and the more extensive data within asset embeddings, which can impair result precision.\n\n\n\n## startswith()\n\n**Syntax:** `startswith(<text_field>|*, <text_literal>)` where:\n- first parameters are the set of fields on which the search is done:\n  - `*` or empty to search on all visible fields\n  - a subset of field names separated with a comma `,`\n- the string to search for as last parameter\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `startswith` function:\n\n```sql\nstartswith(id, \"ID4536\")  -- will match id that start with \"ID4536\"\nstartswith(title, \"SECRET\")  -- will match \"SECRET DEFENSE\" but not \"THE BOOK OF SECRETS\", nor \"book of secret\"\n```\n\nThe `startswith()` function performs a text query on all selected fields of each record and return matching records.\nIt is a prefix search: it matches the text fields that contain **strings** **beginning with** the searched string.\nContrary to the `suggest()` function, the comparison is made on the whole string, without splitting it by spaces and forming **terms** before.\n\nThe matching is **case sensitive**.\n\n\n## within_distance()\n\n**Syntax:** `within_distance(<geo_field>, <center_geometry>, <distance><unit>)`\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `within_distance` function:\n\n```sql\nwithin_distance(field_name, GEOM'<geometry>', 1km)\n\nwithin_distance(field_name, GEOM'<geometry>', 100yd)\n```\n\nThe `within_distance` function limits the result set to a geographical area defined by a circle. This circle must be defined by its center and a distance.\n\n- The center of the circle is expressed as a [geometry literal](#section/Opendatasoft-Query-Language-(ODSQL)/Language-elements).\n- The distance is numeric and can have a unit in:\n\n  - miles (mi)\n  - yards (yd)\n  - feet (ft)\n  - meters (m)\n  - centimeters (cm)\n  - kilometers (km)\n  - millimeters (mm)\n\n## in_bbox()\n\n**Syntax:** `in_bbox(<geo_field>, lat1, lon1, lat2, lon2)`\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\nThis function limits the results to records that have their `<geo_field>` contained in a given bounding box. The bounding box is expressed by giving its two extreme points: (lat1, lon1) for the latitude and longitude of the first point and (lat2, lon2) for the latitude and longitude of the second point.\n\n## intersects()\n\n**Syntax:** `intersects(<geo_field>, <geometry_literal>)`\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `geometry` function:\n\n```sql\nintersects(geo_shape, geom'POLYGON((2.331161 48.869762, 2.3600006 48.87574, 2.373046875 48.85101, 2.3503875 48.84209, 2.3376846 48.85451, 2.3311614 48.869762))')\n```\n\nThe `intersects` function limits the result set to a geographical area that intersects a given geometry.\n\nThis function must be defined with a [geometry literal](#section/Opendatasoft-Query-Language-(ODSQL)/Language-elements).\n\n## disjoint()\n\n**Syntax:** `disjoint(<geo_field>, <geometry_literal>)`\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `geometry` function:\n\n```sql\ndisjoint(geo_shape, geom'POLYGON((2.331161 48.869762, 2.3600006 48.87574, 2.373046875 48.85101, 2.3503875 48.84209, 2.3376846 48.85451, 2.3311614 48.869762))')\n```\n\nThe `disjoint` function limits the result set to a geographical area that is disjoint from a given geometry.\n\nThis function must be defined with a [geometry literal](#section/Opendatasoft-Query-Language-(ODSQL)/Language-elements).\n\n## within()\n\n**Syntax:** `within(<geo_field>, <geometry_literal>)`\n\n**Clauses where it can be used:** `where` only\n\n**Returned type:** boolean\n\n> Examples of a `within` function:\n\n```sql\nwithin(geo_shape, geom'POLYGON((2.331161 48.869762, 2.3600006 48.87574, 2.373046875 48.85101, 2.3503875 48.84209, 2.3376846 48.85451, 2.3311614 48.869762))')\n```\n\nThe `within` function limits the result set to a geographical area that lie within a given geometry.\n\nThis function must be defined with a [geometry literal](#section/Opendatasoft-Query-Language-(ODSQL)/Language-elements).\n\n\n## Text comparison operators\n\n**Clauses where it can be used:** `where` only\n\n| <div style=\"width:110px\">Operator</div> | Description                                                                      |\n| --------------------------------------- | -------------------------------------------------------------------------------- |\n| `=`                                     | Perform an exact query (not tokenized and not normalized) on the specified field |\n\n## Numeric comparison operators\n\n**Clauses where it can be used:** `where` only\n\n| <div style=\"width:110px\">Operator</div> | Description                                                                                                 |\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| `=`                                     | Match a numeric value                                                                                       |\n| `>`,`<`,`>=`,`<=`                       | Return results whose field values are larger, smaller, larger or equal, smaller or equal to the given value |\n\n## Date comparison operators\n\n**Clauses where it can be used:** `where` only\n\n| <div style=\"width:110px\">Operator</div> | Description                                                         |\n| --------------------------------------- | ------------------------------------------------------------------- |\n| `=`                                     | Match a date                                                        |\n| `>`,`<`,`>=`,`<=`                       | Return results whose field date are after or before the given value |\n\n## Boolean field filter\n\n**Syntax:**\n\n- `<boolean_field>`\n- `<boolean_field> is (true|false)`\n\n**Clauses where it can be used:** `where` only\n\nA boolean field filter takes a boolean field and restricts results only if the boolean value is `true`.\n\nThere are 2 ways of creating a filter expression:\n\n- with a field literal only: in that case, it filters the result where the field literal value is `true`\n- with a field literal followed by the `is` keyword, then `true` or `false` keywords\n\n> Examples of a boolean field filter:\n\n```sql\nmy_boolean_field          -- Filters results where boolean_field is true\n\nmy_boolean_field is false -- Filters results where boolean_field is false\n```\n\nwhere `<field_literal>` must be a valid boolean field\n\n## IN filter\n\n**Syntax:**\n\n- on a numeric range: `<field_literal> IN (]|[)<numeric_literal> (TO|..) <numeric_literal>(]|[)`\n- on a date range: `<field_literal> (IN|:) (]|[)<date_literal> (TO|..) <date_literal>(]|[)`\n- on a list: `<field_literal> IN (<literal>, <literal>*)`\n- on a multivalued field: `<literal> IN <field_literal>`\n\n**Clauses where it can be used:** `where` only\n\nAn `IN` filter restricts results using a search in a list or a range of values.\n\nThere are 3 ways of using an `IN` filter:\n- to search that a field's value is present in a numeric or a date range.\n- to search that a field's value is present in a list of literals.\n- to search that a literal value is present in a multivalued field's values.\n\n> Example of an `IN` filter expression on a numeric range:\n\n```sql\nnumeric_field IN [1..10] -- Filters results such as 1 <= numeric_field <= 10\n\nnumeric_field IN ]1..10[ -- Filters results such as 1 < numeric_field < 10\n```\n\n> Example of an `IN` filter expression on a date range:\n\n```sql\ndate_field IN [date'2017'..date'2018'] -- Filters results such as date_field date is between year 2017 and 2018\n```\n\nYou can also use the `:` syntax:\n\n```sql\ndate_field:['2022-03-12' TO '2022-04-27'] -- single quotes for the date parameters\n\ndate_field:[20220312 TO 20220427] -- the date parameters as a full integer\n```\n\n> Note that in the previous example, you don't have to cast the parameter if you use quotes or a full integer. However, this does not work if you don't use quotes or a specific cast such as `date:'YYYY-MM-DD'`. For instance the following example will raise an ODSQL error.\n\n```sql\ndate_field IN [2022-03-12 TO 2022-04-27] -- this is not valid\n```\n\n> Example of an `IN` filter expression on a list of literals:\n\n```sql\nmy_field IN (\"Paris\", \"Nantes\", \"Lorient\", \"BesanÃ§on\") -- Filters results such as my_field is equal to \"Paris\", \"Nantes\", \"Lorient\" or \"BesanÃ§on\"\n```\n\n> Example of an `IN` filter expression on a multivalued field:\n\n```sql\n\"Paris\" IN multivalued_text_field -- Filters results such as the literal \"Paris\" is present in the multivalued field\n15 IN multivalued_int_field -- Same as above but with an integer literal\n12.087 IN mutlivalued_decimal_field -- Same as above but with a decimal literal\ntrue IN mutlivalued_boolean_field -- Same as above but with a boolean literal\n```\n\n\n## IS NULL filter\n\n**Syntax:**\n\n- `<field> is null`\n- `<field> is not null`\n\n**Clauses where it can be used:** `where` only\n\nA null field filter takes a field and restricts results only if the field values are null.\nThe opposite filter, `is not null`, takes a field and restricts results only if the field values are not null.\n\n> Examples of a null filter expression:\n\n```sql\nfilm_name is null      -- matches records where film_name is null\n\nfilm_name is not null  -- matches records where film_name is not null\n```\n\n# ODSQL aggregate functions\n\nAggregation functions are functions that perform a computation on a set of values and return one value. They are usually used in conjunction with a `group_by` clause.\n\n## avg()\n\n**Syntax:** `avg(<numeric_field>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric\n\nThis function takes a numeric field. It returns the average (`avg`) of this field over a group.\n\n> Example of an `avg` aggregation:\n\n```sql\navg(population) as avg_population -- Return the average of the population\n```\n\n## count()\n\n**Syntax:** `count(<field>|*)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** integer\n\nThis function computes a number of elements.\n\nIt accepts the following parameters:\n\n- a field name: only returns the count for non-`null` values of this field\n- a `*`: returns the count of all elements\n\n> Examples of a `count` aggregation:\n\n```sql\ncount(*) -- Return number of elements\n\ncount(population) as population_count_not_empty -- Return number of elements where `population` field is not empty\n```\n\n## count(distinct)\n\n**Syntax:** `count(distinct <field>|*)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** integer\n\nThis function computes the **unique** numbers of elements, eliminating the repetitive appearance of the same data.\n\nIt accepts the following parameters:\n\n- a field name: only returns the number of unique non-`null` values of this field.\n- the function `ifnull(<ods_field>, <alternative_expression>)`: same as above, but replace all `null` values with an alternative expression before counting. See the documentation of the [ifnull function](#section/ODSQL-functions/ifnull()) for more details on its syntax.\n\n**Note:** For performance reasons, the count is always approximated.\n\n> Examples of a `count distinct` aggregation:\n\n```sql\ncount(distinct species) -- Return the number of unique values for the field species\n\ncount(distinct ifnull(species, \"'unknown'\")) -- Same as above, but null values will be counted as equals to 'unknown'\n```\n\n## envelope()\n\n**Syntax:** `envelope(<geo_point_field>)`\n\n**Clauses where it can be used:** `select`\n\n**Returned type:** geo_shape\n\nThis function takes a geo_point field. It returns the convex hull (`envelope`) of all the points of the geo_point field.\n\n> Example of an `envelope` aggregation:\n\n```sql\nenvelope(geo_point) as convex_hull -- Return the convex_hull for the geo_point field\n```\n\n## bbox()\n\n**Syntax:** `bbox(<geo_field>)`\n\n**Clauses where it can be used:** `select`\n\n**Returned type:** geo_shape\n\nThis function takes a geo_point or a geo_shape field. It returns the bounding box of all the geometries.\n\n> Example of an `bbox` aggregation:\n\n```sql\nbbox(geo_point) -- Return the bounding box of all the points\n```\n\n## max()\n\n**Syntax:** `max(<numeric_field>|<date_field>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric or date\n\nThis function takes a numeric or a date field name. It returns the maximum value (`max`) of this field.\n\n> Example of a `max` aggregation:\n\n```sql\nmax(population) as max_population -- Return max value for population field\n```\n\n## median()\n\n**Syntax:** `median(<numeric_field>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric\n\nThis function takes a numeric field name. It returns the median (`median`) of this field's values. Since the median is the 50th percentile, it is a shortcut for `percentile(field, 50)`.\n\n> Example of a `median` aggregation:\n\n```sql\nmedian(age) as med -- Return the median of the age field\n```\n\n## min()\n\n**Syntax:** `max(<numeric_field>|<date_field>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric or date\n\nThis function takes a numeric or a date field name. It returns the minimum value (`min`) of this field.\n\n> Example of a `min` aggregation:\n\n```sql\nmin(population) as min_population -- Return min value for population field\n```\n\n## percentile()\n\n**Syntax:** `percentile(<numeric_field>, <percentile>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric\n\nThis function takes a numeric field name and a percentile. It returns the nth percentile (`percentile`) of this field. Percentile must be a decimal value between `0` and `100`.\n\n> Example of a `percentile` aggregation:\n\n```sql\npercentile(age, 1) as first_percentile -- Return the first percentile of the age field\n```\n\n## sum()\n\n**Syntax:** `sum(<numeric_field>)`\n\n**Clauses where it can be used:** `select`, `order_by`\n\n**Returned type:** numeric\n\nThis function takes a numeric field name as an argument. It returns the sum of all values for a field.\n\n> Example of a `sum` aggregation:\n\n```sql\nsum(population) as sum_population -- Return the sum of all values for the population field\n```\n\n# ODSQL grouping functions\n\nGrouping functions are functions that can be used in the `group_by` clause to separate a set of records into different sets that share a common property. An [aggregate function](#section/ODSQL-aggregate-functions) can then be applied on each group separately.\n\n## range() - group by static ranges\n\n**Syntax for numerical ranges:** `range(<field_literal> [, *]?, <numeric_literal> [,<numeric_literal>]* [, *]?)`\nwhere `<field_literal>` must be a numeric field\n\n**Syntax for date/datetime ranges:** `range(<field_literal> [, *]?, <date_literal> [,<date_literal>]* [, *]?)`\nwhere `<field_literal>` must be a date or datetime field.\n\n**Clauses where it can be used:** `group_by` only\n\nThe static range function takes a variable number of parameters:\n\n- a field name, and\n- a variable number of parameters. Each parameter can be a numerical literal, a date literal or the special syntax `*` to denote infinity.\n\nA `*` as first step makes values lower than the lower bound included in the first group, a `*` as last step makes values greater than the upper bound included in the last group.\n\nNote that the resulting aggregation includes the lower bound and excludes the higher bound.\n\nRanges can be set on numerical fields and on date/datetime fields.\n\nFor a recall, date literals are composed of the `date` identifier followed by a date in ISO format, e.g. `date'2021-02-01'`\n\n> Examples of a group by static ranges expression:\n\n```sql\nRANGE(population, *, 10, 50, 100, *)               -- Creates 4 groups: [*, 9], [10, 49], [50, 99] and [100, *]\nRANGE(population, 20.5, *)                         -- Creates 1 group: [20.5, *[\nRANGE(population, 1,2,3)                           -- Creates 2 groups: [1-1], [2, 2]\nRANGE(date, *, date'2020-11-13', date'2021-01-01') -- Creates 2 groups: [*, 2020-11-13T00:00:00.000Z[ and [2020-11-13T00:00:00.000Z, 2021-01-01T00:00:00.000Z[\n```\n\n## range() - group by ranges of equal widths\n\n**Syntax for numerical fields:** `group_by=range(<field_literal>, <numeric_literal>)` where `<field_literal>` must be a numeric field\n\n**Syntax for date/datetime fields:** `group_by=range(<field_literal>, <integer><interval_unit>)` where `<field_literal>` must be a date/datetime field, and `<interval_unit>` is one of the following (case sensitive) string constants:\n\n- `ms`, `millisecond` or `milliseconds`,\n- `s`, `second` or `seconds`,\n- `m`, `minute` or `minutes`,\n- `h`, `hour` or `hours`,\n- `d`, `day` or `days`,\n- `w`, `week` or `weeks`,\n- `M`, `month` or `months`,\n- `q`, `quarter` or `quarters`,\n- `y`, `year` or `years`.\n\n**Note:** For some interval units (week, month, quarter, and year), an interval value of more than one is not supported yet.\n\n**Clauses where it can be used:** `group_by` only\n\n\nIt is possible to group values of a field by ranges of equal widths, also known as histograms.\n\nRanges of equal widths are supported for numerical fields and date/datetime fields.\n\nThe `range` function for ranges of equal widths takes for parameters:\n\n- a field name, and\n- the desired width of each group.\n\nFor date/datetime fields, the width of each group is expressed by a time interval with a special syntax (see above).\n\n**Note:** groups that do not contain any data are not returned.\n\n> Example of a group by ranges of equal widths expression:\n\n```sql\nRANGE(population, 5)\n```\n\n> `5` is the desired width of each returned group.\n> For values of a `population` field that span from 10 to 28, it creates the following groups:\n\n```markdown\n- [10, 15[\n- [15, 20[\n- [20, 25[\n- [25, 30[\n```\n\n> Example of a date histogram:\n\n```sql\nRANGE(date, 1 day)\n```\n\n> Groups created (one for each day):\n\n```markdown\n- [2020-01-01T00:00:00.000Z, 2020-01-02T00:00:00.000Z[\n- [2020-01-02T00:00:00.000Z, 2020-01-03T00:00:00.000Z[\n- [2020-01-04T00:00:00.000Z, 2020-01-05T00:00:00.000Z[\n- ...\n```\n\n> No group is created for 2020-01-03 since no data is available for this day.\n\n## geo_cluster()\n\n**Syntax:** `group_by=geo_cluster(<geo_point_field>, <zoom_level>[, <radius>])` where:\n- `<zoom_level>` is an integer between 0 and 25\n- `<radius>` is an optional integer. It defaults to 40.\n\n**Clauses where it can be used:** `group_by` only\n\nThis function groups points that are close to each other.\n\nIt first groups points by their [geohash](https://en.wikipedia.org/wiki/Geohash) of a certain level. The level (or precision) of the used geohash grid is determined by both the zoom and the radius parameters:\n- `zoom_level` follows the [\"slippy map\" zoom level hierarchy](https://wiki.openstreetmap.org/wiki/Zoom_levels): at zoom level 0, one tile represents the whole planet and each sub level sub divides the tile into 4 sub tiles.\n- `radius` is expressed in pixels on a tile of 256x256 pixels at the given `zoom_level`\n- the geohash precision is the one where radius in meter is smaller than the geohash cell dimension\n\nA second step merges groups that may have points that are very close. This is to circumvent the \"grid\" effect of the first step.\ne.g. At geohash grid level 1, France is split into 4 geohash cells \"g\", \"u\", \"e\" and \"s\" that cross somewhere north-east from Bordeaux. A dense group of points that lie in a small area around Bordeaux may be split into more than 1 bucket with the first step. This second step is here to join them back.\n\nThe join step is done by:\n- computing the centroid of each group in the first step, in addition to the list of points that lie within,\n- merging groups that have centroids that are closer than the distance given by the radius parameter\n\n# Versioning\n\nThe development of the Explore API V2 continues, new features are added every month and bugs are fixed every week. To ensure that evolutions do not break any application, dashoard or usage, the team guarantees that:\n- ODSQL is backward compatible, new syntax cannot replace existing one\n- responses body are stable, new keys can be added but keys cannot be renamed or deleted\n- urls and endpoints are stable\n\nSome features require to go deeper and to introduce a breaking change. A breaking change is a violation of one or multiple of our warranties listed above (e.g., a different syntax in ODSQL, a modification of the response body structure, etc.). To ensure that it won't break any existing usage, these changes will be part of a new API version.\n\nAn API version is composed of:\n- a stable url, which is `/api/explore/v2.1` for the version ${{api_versi- an exhaustive documentation, available on the [Helphub](https://help.opendatasoft.com/apis/ods-explore-v2/)\n\nWhen a new version is available, the team will communicate the release notes widely and be available to help on migration. Previous version response contains a header `ODS-Explore-API-Deprecation`.\n\n## Deprecation warnings\n\nWhen a feature needs to be changed in a breaking way, the new behaviour is introduced in a new version and the behaviour stays the same for the current version. The API response may contain in this case dedicated HTTP headers that give information about the possible deprecation of a used feature:\n- `ODS-Explore-API-Deprecation` will contain deprecation messages (separated by `;` if there are multiple messages). A deprecation message has the following formatting: `<FEATURE_ID>: deprecation message`. e.g. `DATE_KEYS_AS_ISOFORMAT: Dates used in group keys are currently returned as timestamps and will be returned as standard formatted date strings in the next API version`\n- `Link` contains the URL of the version changelog\n\n",
    "contact": {
      "email": "support@opendatasoft.com"
    },
    "license": {
      "name": "Copyright Opendatasoft"
    }
  },
  "servers": [
    {
      "url": "https://documentation-resources.opendatasoft.com/api/explore/v2.1",
      "description": "Portal that hosts example datasets"
    }
  ],
  "security": [
    {
      "apikey": []
    }
  ],
  "tags": [
    {
      "name": "Catalog",
      "description": "API to enumerate datasets"
    },
    {
      "name": "Dataset",
      "description": "API to work on records"
    }
  ],
  "paths": {
    "/catalog/datasets": {
      "get": {
        "summary": "Query catalog datasets",
        "operationId": "getDatasets",
        "tags": [
          "Catalog"
        ],
        "description": "Retrieve available datasets.",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/order_by"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/offset"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          },
          {
            "$ref": "#/components/parameters/group_by"
          },
          {
            "$ref": "#/components/parameters/include_links"
          },
          {
            "$ref": "#/components/parameters/include_app_metas"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of available datasets",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "$ref": "#/components/schemas/results_dataset-v2.1"
                },
                "examples": {
                  "datasets": {
                    "$ref": "#/components/examples/datasets-v2.1"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/exports": {
      "get": {
        "summary": "List export formats",
        "operationId": "listExportFormats",
        "tags": [
          "Catalog"
        ],
        "description": "List available export formats",
        "responses": {
          "200": {
            "description": "A list of available export formats",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "links": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/links"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/exports/{format}": {
      "get": {
        "summary": "Export a catalog",
        "operationId": "exportDatasets",
        "tags": [
          "Catalog"
        ],
        "description": "Export a catalog in the desired format.",
        "parameters": [
          {
            "$ref": "#/components/parameters/format-catalog-v2.1"
          },
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/order_by"
          },
          {
            "$ref": "#/components/parameters/group_by"
          },
          {
            "$ref": "#/components/parameters/limit_export"
          },
          {
            "$ref": "#/components/parameters/offset"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/exports/csv": {
      "get": {
        "summary": "Export a catalog in CSV",
        "operationId": "exportCatalogCSV",
        "tags": [
          "Catalog"
        ],
        "description": "Export a catalog in CSV (Comma Separated Values). Specific parameters are described here",
        "parameters": [
          {
            "name": "delimiter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                ";",
                ",",
                "\t",
                "|"
              ],
              "default": ";"
            },
            "description": "Sets the field delimiter of the CSV export"
          },
          {
            "name": "list_separator",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": ","
            },
            "description": "Sets the separator character used for multivalued strings"
          },
          {
            "name": "quote_all",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            },
            "description": "Set it to true to force quoting all strings, i.e. surrounding all strings with quote characters"
          },
          {
            "name": "with_bom",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            },
            "description": "Set it to true to force the first characters of the CSV file to be a Unicode Byte Order Mask (0xFEFF). It usually makes Excel correctly open the output CSV file without warning.\n**Warning:** the default value of this parameter is `false` in v2.0 and `true` starting with v2.1"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/exports/dcat{dcat_ap_format}": {
      "get": {
        "summary": "Export a catalog in RDF/XML (DCAT)",
        "operationId": "exportCatalogDCAT",
        "tags": [
          "Catalog"
        ],
        "description": "Export a catalog in RDF/XML described with DCAT (Data Catalog Vocabulary). Specific parameters are described here",
        "parameters": [
          {
            "$ref": "#/components/parameters/dcat_format"
          },
          {
            "name": "include_exports",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/enum-format-datasets-v2.1"
            },
            "description": "Sets the datasets exports exposed in the DCAT export. By default, all exports are exposed.",
            "examples": {
              "legacy": {
                "summary": "Only expose csv, json and geojson datasets exports",
                "value": "csv,json,geojson"
              }
            }
          },
          {
            "name": "use_labels_in_exports",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            },
            "description": "If set to `true`, this parameter will make distributions output the label of each field rather than its name. This parameter only applies on distributions that contain a list of the fields in their output (e.g., CSV, XLSX)."
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/facets": {
      "get": {
        "summary": "List facet values",
        "operationId": "getDatasetsFacets",
        "tags": [
          "Catalog"
        ],
        "description": "Enumerate facet values for datasets and returns a list of values for each facet.\nCan be used to implement guided navigation in large result sets.",
        "parameters": [
          {
            "$ref": "#/components/parameters/facet"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/timezone"
          }
        ],
        "responses": {
          "200": {
            "description": "An enumeration of facets",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "links": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/links"
                      }
                    },
                    "facets": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/facet_enumeration"
                      }
                    }
                  }
                },
                "examples": {
                  "catalog_facets": {
                    "$ref": "#/components/examples/catalog_facets"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/records": {
      "get": {
        "summary": "Query dataset records",
        "operationId": "getRecords",
        "tags": [
          "Dataset"
        ],
        "description": "Perform a query on dataset records.",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/group_by"
          },
          {
            "$ref": "#/components/parameters/order_by"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/offset"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          },
          {
            "$ref": "#/components/parameters/include_links"
          },
          {
            "$ref": "#/components/parameters/include_app_metas"
          }
        ],
        "responses": {
          "200": {
            "description": "Records",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "$ref": "#/components/schemas/results-v2.1"
                },
                "examples": {
                  "records": {
                    "$ref": "#/components/examples/records"
                  },
                  "group_by_country": {
                    "$ref": "#/components/examples/group_by_country-v2.1"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/exports": {
      "get": {
        "summary": "List export formats",
        "operationId": "listDatasetExportFormats",
        "tags": [
          "Dataset"
        ],
        "description": "List available export formats",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of available export formats",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "links": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/links"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/exports/{format}": {
      "get": {
        "summary": "Export a dataset",
        "operationId": "exportRecords",
        "tags": [
          "Dataset"
        ],
        "description": "Export a dataset in the desired format.\n**Note:** The `group_by` parameter is only available on exports starting with the v2.1",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "$ref": "#/components/parameters/format-datasets-v2.1"
          },
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/order_by"
          },
          {
            "$ref": "#/components/parameters/group_by"
          },
          {
            "$ref": "#/components/parameters/limit_export"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          },
          {
            "$ref": "#/components/parameters/use_labels"
          },
          {
            "$ref": "#/components/parameters/compressed"
          },
          {
            "$ref": "#/components/parameters/epsg"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/exports/csv": {
      "get": {
        "summary": "Export a dataset in CSV",
        "operationId": "exportRecordsCSV",
        "tags": [
          "Dataset"
        ],
        "description": "Export a dataset in CSV (Comma Separated Values). Specific parameters are described here",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "name": "delimiter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                ";",
                ",",
                "\t",
                "|"
              ],
              "default": ";"
            },
            "description": "Sets the field delimiter of the CSV export"
          },
          {
            "name": "list_separator",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": ","
            },
            "description": "Sets the separator character used for multivalued strings"
          },
          {
            "name": "quote_all",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            },
            "description": "Set it to true to force quoting all strings, i.e. surrounding all strings with quote characters"
          },
          {
            "name": "with_bom",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            },
            "description": "Set it to true to force the first characters of the CSV file to be a Unicode Byte Order Mask (0xFEFF). It usually makes Excel correctly open the output CSV file without warning.\n**Warning:** the default value of this parameter is `false` in v2.0 and `true` starting with v2.1"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/exports/parquet": {
      "get": {
        "summary": "Export a dataset in Parquet",
        "operationId": "exportRecordsParquet",
        "tags": [
          "Dataset"
        ],
        "description": "Export a dataset in Parquet. Specific parameters are described here",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "name": "parquet_compression",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "snappy",
                "zstd"
              ],
              "default": "snappy"
            },
            "description": "Sets the compression parameter for the Parquet export file"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/exports/gpx": {
      "get": {
        "summary": "Export a dataset in GPX",
        "operationId": "exportRecordsGPX",
        "tags": [
          "Dataset"
        ],
        "description": "Export a dataset in GPX. Specific parameters are described here",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "name": "name_field",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Sets the field that is used as the 'name' attribute in the GPX output"
          },
          {
            "name": "description_field_list",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Sets the fields to use in the 'description' attribute of the GPX output"
          },
          {
            "name": "use_extension",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            },
            "description": "Set it to true to use the `<extension>` tag for attributes (as GDAL does). Set it to false to use the `<desc>` tag for attributes.\n**Warning:** the default value of this parameter is `false` in v2.0 and `true` starting with v2.1"
          }
        ],
        "responses": {
          "200": {
            "description": "Return a file"
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}": {
      "get": {
        "summary": "Show dataset information",
        "operationId": "getDataset",
        "tags": [
          "Catalog"
        ],
        "description": "Returns a list of available endpoints for the specified dataset, with metadata and endpoints.\n\nThe response includes the following links:\n* the attachments endpoint\n* the files endpoint\n* the records endpoint\n* the catalog endpoint.",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          },
          {
            "$ref": "#/components/parameters/include_links"
          },
          {
            "$ref": "#/components/parameters/include_app_metas"
          }
        ],
        "responses": {
          "200": {
            "description": "The dataset",
            "content": {
              "application/json; charset=utf-8json": {
                "schema": {
                  "$ref": "#/components/schemas/dataset-v2.1"
                },
                "examples": {
                  "dataset": {
                    "$ref": "#/components/examples/dataset-v2.1"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/facets": {
      "get": {
        "summary": "List dataset facets",
        "operationId": "getRecordsFacets",
        "tags": [
          "Dataset"
        ],
        "description": "Enumerates facet values for records and returns a list of values for each facet.\nCan be used to implement guided navigation in large result sets.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "$ref": "#/components/parameters/where"
          },
          {
            "$ref": "#/components/parameters/refine"
          },
          {
            "$ref": "#/components/parameters/exclude"
          },
          {
            "$ref": "#/components/parameters/facet"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          }
        ],
        "responses": {
          "200": {
            "description": "Facets enumeration",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "links": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/links"
                      }
                    },
                    "facets": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/facet_enumeration"
                      }
                    }
                  }
                },
                "examples": {
                  "facets": {
                    "$ref": "#/components/examples/facets"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/attachments": {
      "get": {
        "summary": "List dataset attachments",
        "operationId": "getDatasetAttachments",
        "tags": [
          "Dataset"
        ],
        "description": "Returns a list of all available attachments for a dataset.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          }
        ],
        "responses": {
          "200": {
            "description": "List of all available attachments",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "links": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/links"
                      }
                    },
                    "attachments": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/attachment"
                      }
                    }
                  }
                },
                "examples": {
                  "attachments": {
                    "$ref": "#/components/examples/attachments"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/catalog/datasets/{dataset_id}/records/{record_id}": {
      "get": {
        "summary": "Read a dataset record",
        "operationId": "getRecord",
        "tags": [
          "Dataset"
        ],
        "description": "Reads a single dataset record based on its identifier.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/dataset_id"
          },
          {
            "$ref": "#/components/parameters/record_id"
          },
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/lang"
          },
          {
            "$ref": "#/components/parameters/timezone"
          }
        ],
        "responses": {
          "200": {
            "description": "A single record",
            "content": {
              "application/json; charset=utf-8": {
                "schema": {
                  "$ref": "#/components/schemas/record"
                },
                "examples": {
                  "record": {
                    "$ref": "#/components/examples/record"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/bad_request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "429": {
            "$ref": "#/components/responses/quota"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "apikey": {
        "type": "apiKey",
        "description": "API key to make authenticated requests.",
        "name": "apikey",
        "in": "query"
      }
    },
    "parameters": {
      "select": {
        "name": "select",
        "in": "query",
        "description": "Examples:\n- `select=size` - Example of select, which only return the \"size\" field.\n- `select=size * 2 as bigger_size` - Example of a complex expression with a label, which returns a new field named \"bigger_size\" and containing the double of size field value.\n- `select=dataset_id, fields` - Example of a select in catalog ODSQL query to only retrieve dataset_id and schema of datasets.\n\nA select expression can be used to add, remove or change the fields to return.\nAn expression can be:\n  - a wildcard ('*'): all fields are returned.\n  - A field name: only the specified field is returned.\n  - An include/exclude function: All fields matching the include or exclude expression are included or excluded. This expression can contain wildcard.\n  - A complex expression. The result of the expression is returned. A label can be set for this expression, and in that case, the field will be named after this label.",
        "schema": {
          "type": "string"
        }
      },
      "where": {
        "name": "where",
        "in": "query",
        "description": "A `where` filter is a text expression performing a simple full-text search that can also include logical operations\n(NOT, AND, OR...) and lots of other functions to perform complex and precise search operations.\n\nFor more information, see [Opendatasoft Query Language (ODSQL)](<https://help.opendatasoft.com/apis/ods-explore-v2/#section/Opendatasoft-Query-Language-(ODSQL)/Where-clause>) reference documentation.",
        "schema": {
          "type": "string"
        }
      },
      "order_by": {
        "name": "order_by",
        "in": "query",
        "description": "Example: `order_by=sum(age) desc, name asc`\n\nA comma-separated list of field names or aggregations to sort on, followed by an order (`asc` or `desc`).\n\nResults are sorted in ascending order by default. To sort results in descending order, use the `desc` keyword.",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "string"
        }
      },
      "limit": {
        "name": "limit",
        "in": "query",
        "description": "Number of items to return.\n\nTo use with the `offset` parameter to implement pagination.\n\nThe maximum possible value depends on whether the query contains a `group_by` clause or not.\n\nFor a query **without** a `group_by`:\n  - the maximum value for `limit` is 100,\n  - `offset+limit` should be less than 10000\n\nFor a query **with** a `group_by`:\n  - the maximum value for `limit` is 20000,\n  - `offset+limit` should be less than 20000\n\n**Note:** If you need more results, please use the /exports endpoint.\n",
        "schema": {
          "maximum": 100,
          "minimum": -1,
          "type": "integer",
          "default": 10
        }
      },
      "offset": {
        "name": "offset",
        "in": "query",
        "description": "Index of the first item to return (starting at 0).\n\nTo use with the `limit` parameter to implement pagination.\n\n**Note:** the maximum value depends on the type of query, see the note on `limit` for the details\n",
        "schema": {
          "minimum": 0,
          "type": "integer",
          "default": 0
        }
      },
      "refine": {
        "name": "refine",
        "in": "query",
        "description": "Example: `refine=modified:2020` - Return only the value `2020` from the `modified` facet.\n\nA facet filter used to limit the result set.\nUsing this parameter, you can refine your query to display only the selected facet value in the response.\n\nRefinement uses the following syntax: `refine=<FACETNAME>:<FACETVALUE>`\n\nFor date, and other hierarchical facets, when refining on one value, all second-level values related to that entry will appear in facets enumeration. For example, after refining on the year 2019, the related second-level month will appear. And when refining on August 2019, the third-level day will appear.\n\n**`refine` must not be confused with a `where` filter. Refining with a facet is equivalent to selecting an entry in the left navigation panel.**",
        "style": "form",
        "explode": true,
        "schema": {
          "type": "string"
        }
      },
      "exclude": {
        "name": "exclude",
        "in": "query",
        "description": "Examples:\n- `exclude=city:Paris` - Exclude the value `Paris` from the `city` facet. Facets enumeration will display `Paris` as `excluded` without any count information.\n- `exclude=modified:2019/12` - Exclude the value `2019/12` from the `modified` facet. Facets enumeration will display `2020` as `excluded` without any count information.\n\nA facet filter used to exclude a facet value from the result set.\nUsing this parameter, you can filter your query to exclude the selected facet value in the response.\n\n`exclude` uses the following syntax: `exclude=<FACETNAME>:<FACETVALUE>`\n\n**`exclude` must not be confused with a `where` filter. Excluding a facet value is equivalent to removing an entry in the left navigation panel.**",
        "style": "form",
        "explode": true,
        "schema": {
          "type": "string"
        }
      },
      "lang": {
        "name": "lang",
        "in": "query",
        "description": "A language value.\n\nIf specified, the `lang` value override the default language, which is \"fr\".\nThe language is used to format string, for example in the `date_format` function.",
        "schema": {
          "type": "string",
          "enum": [
            "en",
            "fr",
            "nl",
            "pt",
            "it",
            "ar",
            "de",
            "es",
            "ca",
            "eu",
            "sv"
          ]
        },
        "style": "form"
      },
      "timezone": {
        "name": "timezone",
        "in": "query",
        "description": "Set the timezone for datetime fields.\n\nTimezone IDs are defined by the [Unicode CLDR project](https://github.com/unicode-org/cldr). The list of timezone IDs is available in [timezone.xml](https://github.com/unicode-org/cldr/blob/master/common/bcp47/timezone.xml).",
        "schema": {
          "type": "string",
          "default": "UTC"
        },
        "examples": {
          "UTC": {
            "summary": "UTC timezone",
            "value": "UTC"
          },
          "Europe/Paris": {
            "summary": "Paris timezone",
            "value": "Europe/Paris"
          },
          "US/Eastern": {
            "summary": "Eastern timezone",
            "value": "US/Eastern"
          },
          "Europe/London": {
            "summary": "London timezone",
            "value": "Europe/London"
          },
          "Europe/Berlin": {
            "summary": "Berlin timezone",
            "value": "Europe/Berlin"
          }
        }
      },
      "group_by": {
        "name": "group_by",
        "in": "query",
        "description": "Example: `group_by=city_field as city`\n\nA group by expression defines a grouping function for an aggregation.\nIt can be:\n - a field name: group result by each value of this field\n - a range function: group result by range\n - a date function: group result by date\n\nIt is possible to specify a custom name with the 'as name' notation.",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "string"
        }
      },
      "include_links": {
        "name": "include_links",
        "in": "query",
        "description": "If set to `true`, this parameter will add HATEOAS links in the response.\n",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "include_app_metas": {
        "name": "include_app_metas",
        "in": "query",
        "description": "If set to `true`, this parameter will add application metadata to the response.\n",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "format-catalog-v2.1": {
        "name": "format",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "enum": [
            "csv",
            "data.json",
            "dcat",
            "dcat_ap_ch",
            "dcat_ap_de",
            "dcat_ap_se",
            "dcat_ap_sp",
            "dcat_ap_it",
            "dcat_ap_vl",
            "dcat_ap_benap",
            "dublin_core",
            "json",
            "rdf",
            "rss",
            "ttl",
            "xlsx"
          ],
          "description": "Format specifier for the catalog export.\n`dcat_ap_*` formats are only available upon activation.\nSee [here](#tag/Catalog/operation/listExportFormats) to get the list of available export formats"
        },
        "style": "simple"
      },
      "limit_export": {
        "name": "limit",
        "in": "query",
        "description": "Number of items to return in export.\n\nUse -1 (default) to retrieve all records\n",
        "schema": {
          "minimum": -1,
          "type": "integer",
          "default": -1
        }
      },
      "dcat_format": {
        "name": "dcat_ap_format",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "enum": [
            "_ap_ch",
            "_ap_de",
            "_ap_se",
            "_ap_sp",
            "_ap_it",
            "_ap_vl",
            "_ap_benap"
          ],
          "description": "DCAT format specifier for the catalog export.\n`dcat_ap_*` formats are only available upon activation."
        },
        "style": "simple"
      },
      "facet": {
        "name": "facet",
        "in": "query",
        "description": "A facet is a field used for simple filtering (through the `refine` and `exclude` parameters) or exploration (with the `/facets` endpoint).\n\nIt can also be a function such as `facet=facet(name=\"field_name\")` which is identical to `facet=field_name`. But this `facet()` function\ncan also take some optional arguments such as `disjunctive`, `hierarchical`, `separator`, `sort` and `limit`.\n\n* `disjunctive`: a boolean `true/false`, whether multiple values can be selected for the facet\n* `hierarchical`: a boolean `true/false` if the field is hierarchical. The separator must be given as the argument.\n   For instance, you can do `facet=facet(name=\"filepath\", hierarchical=true, separator=\"/\")` to retrieve facets related to this field which might look like `\"/home/user/file.txt\"`\n* `separator`: a string, e.g. `/`, `-`, `;`\n* `sort`: a string which describes how to sort the facets. Possible arguments are `count` and `-count` for all field types, `alphanum` and `-alphanum` for `date`, `datetime` and `text`, `num` and `-num` for `decimal` and `int`\n* `limit`: an integer to limit the number of results\n",
        "style": "form",
        "explode": true,
        "schema": {
          "type": "string"
        }
      },
      "dataset_id": {
        "name": "dataset_id",
        "in": "path",
        "description": "The identifier of the dataset to be queried.\n\nYou can find it in the \"Information\" tab of the dataset page or in the dataset URL, right after `/datasets/`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "format-datasets-v2.1": {
        "name": "format",
        "in": "path",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/enum-format-datasets-v2.1"
        },
        "style": "simple"
      },
      "use_labels": {
        "name": "use_labels",
        "in": "query",
        "description": "If set to `true`, this parameter will make exports output the label of each field rather than its name.\n\nThis parameter only makes sense for formats that contain a list of the fields in their output.\n",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "compressed": {
        "name": "compressed",
        "in": "query",
        "description": "If set to `true`, this parameter can compress the output file of a specific export format with GZIP, e.g. `.csv.gzip`.\n",
        "required": false,
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "epsg": {
        "name": "epsg",
        "in": "query",
        "description": "This parameter sets the EPSG code to project shapes into for formats that support geometric features.\n",
        "schema": {
          "type": "integer",
          "default": 4326
        }
      },
      "record_id": {
        "name": "record_id",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "Record identifier"
      }
    },
    "schemas": {
      "links": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "format": "uri"
          },
          "rel": {
            "type": "string",
            "enum": [
              "self",
              "first",
              "last",
              "next",
              "dataset",
              "catalog"
            ]
          }
        }
      },
      "dataset-v2.1": {
        "type": "object",
        "properties": {
          "_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/links"
            }
          },
          "dataset_id": {
            "type": "string"
          },
          "dataset_uid": {
            "type": "string",
            "readOnly": true
          },
          "attachments": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "mimetype": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                },
                "id": {
                  "type": "string"
                },
                "title": {
                  "type": "string"
                }
              }
            }
          },
          "has_records": {
            "type": "boolean"
          },
          "data_visible": {
            "type": "boolean"
          },
          "features": {
            "type": "array",
            "description": "A map of available features for a dataset, with the fields they apply to.\n",
            "items": {
              "type": "string"
            }
          },
          "metas": {
            "type": "object"
          },
          "fields": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "label": {
                  "type": "string"
                },
                "type": {
                  "type": "string"
                },
                "annotations": {
                  "type": "object"
                },
                "description": {
                  "type": "string",
                  "nullable": true
                }
              }
            }
          },
          "additionalProperties": {}
        }
      },
      "results_dataset-v2.1": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer"
          },
          "_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/links"
            }
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataset-v2.1"
            }
          }
        }
      },
      "enum-format-datasets-v2.1": {
        "type": "string",
        "enum": [
          "csv",
          "fgb",
          "geojson",
          "gpx",
          "json",
          "jsonl",
          "jsonld",
          "kml",
          "n3",
          "ov2",
          "parquet",
          "rdfxml",
          "shp",
          "turtle",
          "xlsx"
        ]
      },
      "facet_value_enumeration": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "count": {
            "type": "integer"
          },
          "value": {
            "type": "string"
          },
          "state": {
            "type": "string"
          }
        }
      },
      "facet_enumeration": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "facets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/facet_value_enumeration"
            }
          }
        }
      },
      "record-v2.1": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "_timestamp": {
            "type": "string",
            "format": "dateTime"
          },
          "_size": {
            "type": "integer",
            "format": "int64"
          },
          "_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/links"
            }
          },
          "field1": {
            "type": "string"
          },
          "field2": {
            "type": "integer"
          }
        },
        "additionalProperties": {}
      },
      "results-v2.1": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer"
          },
          "_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/links"
            }
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/record-v2.1"
            }
          }
        }
      },
      "attachment": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string"
          },
          "metas": {
            "type": "object",
            "properties": {
              "mime-type": {
                "type": "string"
              },
              "title": {
                "type": "string"
              },
              "url": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            }
          }
        }
      },
      "record": {
        "type": "object",
        "properties": {
          "record": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "timestamp": {
                "type": "string",
                "format": "dateTime"
              },
              "size": {
                "type": "integer",
                "format": "int64"
              },
              "fields": {
                "type": "object",
                "properties": {
                  "field1": {
                    "type": "string"
                  },
                  "field2": {
                    "type": "integer"
                  }
                },
                "additionalProperties": {}
              }
            }
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/links"
            }
          }
        }
      }
    },
    "examples": {
      "datasets-v2.1": {
        "value": {
          "total_count": 19,
          "results": [
            {
              "dataset_id": "world-administrative-boundaries-countries-and-territories",
              "dataset_uid": "da_6kvv9v",
              "attachments": [],
              "has_records": true,
              "data_visible": true,
              "fields": [
                {
                  "annotations": {},
                  "description": null,
                  "type": "geo_point_2d",
                  "name": "geo_point_2d",
                  "label": "Geo Point"
                },
                {
                  "annotations": {},
                  "description": null,
                  "type": "geo_shape",
                  "name": "geo_shape",
                  "label": "Geo Shape"
                },
                {
                  "description": null,
                  "label": "Status",
                  "type": "text",
                  "name": "status",
                  "annotations": {
                    "facet": []
                  }
                },
                {
                  "description": "ISO 3 code of the country to which the territory belongs",
                  "label": "ISO 3 country code",
                  "type": "text",
                  "name": "color_code",
                  "annotations": {
                    "facet": []
                  }
                },
                {
                  "description": null,
                  "label": "Region of the territory",
                  "type": "text",
                  "name": "region",
                  "annotations": {
                    "facet": []
                  }
                },
                {
                  "description": null,
                  "label": "ISO 3 territory code",
                  "type": "text",
                  "name": "iso3",
                  "annotations": {
                    "sortable": []
                  }
                },
                {
                  "description": null,
                  "label": "Continent of the territory",
                  "type": "text",
                  "name": "continent",
                  "annotations": {
                    "facet": []
                  }
                },
                {
                  "description": "Name of the territory",
                  "label": "English Name",
                  "type": "text",
                  "name": "name",
                  "annotations": {
                    "sortable": []
                  }
                },
                {
                  "annotations": {},
                  "description": null,
                  "type": "text",
                  "name": "iso_3166_1_alpha_2_codes",
                  "label": "ISO 3166-1 Alpha 2-Codes"
                },
                {
                  "annotations": {},
                  "label": "French Name",
                  "type": "text",
                  "name": "french_short",
                  "description": "French term, when it is available in https://data.opendatasoft.com/explore/dataset/countries-territories-taxonomy-mvp-ct-taxonomy-with-hxl-tags1@public/table/, English name otherwise"
                }
              ],
              "metas": {
                "default": {
                  "records_count": 256,
                  "modified": "2021-06-23T14:59:57+00:00",
                  "source_domain_address": null,
                  "references": "https://geonode.wfp.org/layers/geonode:wld_bnd_adm0_wfp",
                  "keyword": [
                    "United Nation",
                    "ISO-3 code",
                    "Countries",
                    "Territories",
                    "Shape",
                    "Boundaries"
                  ],
                  "source_domain_title": null,
                  "geographic_reference": [
                    "world"
                  ],
                  "timezone": null,
                  "title": "World Administrative Boundaries - Countries and Territories",
                  "parent_domain": null,
                  "theme": [
                    "Administration, Government, Public finances, Citizenship"
                  ],
                  "modified_updates_on_data_change": false,
                  "metadata_processed": "2021-06-23T15:00:02.656000+00:00",
                  "data_processed": "2019-05-15T07:49:01+00:00",
                  "territory": [
                    "World"
                  ],
                  "description": "<p>This dataset displays level 0 world administrative boundaries. It contains countries as well as non-sovereign territories (like, for instance, French overseas).Â </p>",
                  "modified_updates_on_metadata_change": false,
                  "shared_catalog": null,
                  "source_domain": null,
                  "attributions": null,
                  "geographic_area_mode": null,
                  "geographic_reference_auto": true,
                  "geographic_area": null,
                  "publisher": "World Food Programme (UN agency)",
                  "language": "en",
                  "license": "Open Government Licence v3.0",
                  "source_dataset": null,
                  "metadata_languages": [
                    "en"
                  ],
                  "oauth_scope": null,
                  "federated": true,
                  "license_url": "http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/"
                }
              },
              "features": [
                "analyze",
                "geo"
              ]
            },
            {
              "dataset_id": "geonames-all-cities-with-a-population-1000",
              "dataset_uid": "da_5m8ykr",
              "attachments": [
                {
                  "mimetype": "application/zip",
                  "url": "odsfile://cities1000.zip",
                  "id": "cities1000_zip",
                  "title": "cities1000.zip"
                }
              ],
              "has_records": true,
              "data_visible": true,
              "fields": [
                {
                  "description": null,
                  "label": "Geoname ID",
                  "type": "text",
                  "name": "geoname_id",
                  "annotations": {
                    "facetsort": [
                      "-count"
                    ],
                    "id": []
                  }
                },
                {
                  "description": null,
                  "label": "Name",
                  "type": "text",
                  "name": "name",
                  "annotations": {
                    "sortable": []
                  }
                },
                {
                  "description": null,
                  "label": "ASCII Name",
                  "type": "text",
                  "name": "ascii_name",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Alternate Names",
                  "type": "text",
                  "name": "alternate_names",
                  "annotations": {
                    "multivalued": [
                      ","
                    ]
                  }
                },
                {
                  "description": "see http://www.geonames.org/export/codes.html",
                  "label": "Feature Class",
                  "type": "text",
                  "name": "feature_class",
                  "annotations": {}
                },
                {
                  "description": "see http://www.geonames.org/export/codes.html",
                  "label": "Feature Code",
                  "type": "text",
                  "name": "feature_code",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Country Code",
                  "type": "text",
                  "name": "country_code",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Country name EN",
                  "type": "text",
                  "name": "cou_name_en",
                  "annotations": {
                    "facet": [],
                    "facetsort": [
                      "alphanum"
                    ],
                    "disjunctive": []
                  }
                },
                {
                  "description": null,
                  "label": "Country Code 2",
                  "type": "text",
                  "name": "country_code_2",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Admin1 Code",
                  "type": "text",
                  "name": "admin1_code",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Admin2 Code",
                  "type": "text",
                  "name": "admin2_code",
                  "annotations": {
                    "facetsort": [
                      "-count"
                    ]
                  }
                },
                {
                  "description": null,
                  "label": "Admin3 Code",
                  "type": "text",
                  "name": "admin3_code",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Admin4 Code",
                  "type": "text",
                  "name": "admin4_code",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Population",
                  "type": "int",
                  "name": "population",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Elevation",
                  "type": "text",
                  "name": "elevation",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "DIgital Elevation Model",
                  "type": "int",
                  "name": "dem",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Timezone",
                  "type": "text",
                  "name": "timezone",
                  "annotations": {
                    "facet": [],
                    "hierarchical": [
                      "/"
                    ]
                  }
                },
                {
                  "description": null,
                  "label": "Modification date",
                  "type": "date",
                  "name": "modification_date",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "LABEL EN",
                  "type": "text",
                  "name": "label_en",
                  "annotations": {}
                },
                {
                  "description": null,
                  "label": "Coordinates",
                  "type": "geo_point_2d",
                  "name": "coordinates",
                  "annotations": {
                    "facetsort": [
                      "-count"
                    ]
                  }
                }
              ],
              "metas": {
                "default": {
                  "records_count": 137609,
                  "modified": "2021-06-23T14:37:45+00:00",
                  "source_domain_address": null,
                  "references": null,
                  "keyword": null,
                  "source_domain_title": null,
                  "geographic_reference": [
                    "world"
                  ],
                  "timezone": null,
                  "title": "Geonames - All Cities with a population > 1000",
                  "parent_domain": null,
                  "theme": null,
                  "modified_updates_on_data_change": false,
                  "metadata_processed": "2021-06-23T14:49:23.198000+00:00",
                  "data_processed": "2021-06-23T14:49:23+00:00",
                  "territory": [
                    "World"
                  ],
                  "description": null,
                  "modified_updates_on_metadata_change": false,
                  "shared_catalog": null,
                  "source_domain": null,
                  "attributions": null,
                  "geographic_area_mode": null,
                  "geographic_reference_auto": true,
                  "geographic_area": null,
                  "publisher": null,
                  "language": "en",
                  "license": null,
                  "source_dataset": null,
                  "metadata_languages": [
                    "en"
                  ],
                  "oauth_scope": null,
                  "federated": false,
                  "license_url": null
                }
              },
              "features": [
                "geo",
                "analyze",
                "timeserie"
              ]
            }
          ]
        }
      },
      "catalog_facets": {
        "value": {
          "links": [],
          "facets": [
            {
              "name": "publisher",
              "facets": [
                {
                  "count": 2,
                  "state": "displayed",
                  "name": "Opendatasoft",
                  "value": "Opendatasoft"
                },
                {
                  "count": 2,
                  "state": "displayed",
                  "name": "Opendatasoft - Data Team",
                  "value": "Opendatasoft - Data Team"
                }
              ]
            },
            {
              "name": "features",
              "facets": [
                {
                  "count": 19,
                  "state": "displayed",
                  "name": "analyze",
                  "value": "analyze"
                },
                {
                  "count": 13,
                  "state": "displayed",
                  "name": "timeserie",
                  "value": "timeserie"
                }
              ]
            },
            {
              "name": "language",
              "facets": [
                {
                  "count": 17,
                  "state": "displayed",
                  "name": "en",
                  "value": "en"
                },
                {
                  "count": 4,
                  "state": "displayed",
                  "name": "fr",
                  "value": "fr"
                }
              ]
            }
          ]
        }
      },
      "records": {
        "value": {
          "total_count": 137611,
          "links": [],
          "records": [
            {
              "links": [],
              "record": {
                "id": "53d4524dcb82c676bacd467cd5ace953f2e0389c",
                "timestamp": "2021-06-22T08:02:59.954Z",
                "size": 194,
                "fields": {
                  "admin1_code": "27",
                  "elevation": null,
                  "name": "Saint-Leu",
                  "modification_date": "2019-03-26",
                  "alternate_names": [
                    "Saint-Leu"
                  ],
                  "feature_class": "P",
                  "admin3_code": "711",
                  "cou_name_en": "France",
                  "coordinates": {
                    "lat": 46.7306,
                    "lon": 4.50083
                  },
                  "country_code_2": null,
                  "geoname_id": "2978771",
                  "feature_code": "PPL",
                  "label_en": "France",
                  "dem": 366,
                  "country_code": "FR",
                  "ascii_name": "Saint-Leu",
                  "timezone": "Europe/Paris",
                  "admin2_code": "71",
                  "admin4_code": "71436",
                  "population": 29278
                }
              }
            },
            {
              "links": [],
              "record": {
                "id": "d5251445f329dc74cc5c5e30c95378eb9807a019",
                "timestamp": "2021-06-22T08:02:59.954Z",
                "size": 310,
                "fields": {
                  "admin1_code": "32",
                  "elevation": null,
                  "name": "Saint-LÃ©ger-lÃ¨s-Domart",
                  "modification_date": "2016-02-18",
                  "alternate_names": [
                    "Saint-Leger",
                    "Saint-Leger-les-Domart",
                    "Saint-LÃ©ger",
                    "Saint-LÃ©ger-lÃ¨s-Domart"
                  ],
                  "feature_class": "P",
                  "admin3_code": "802",
                  "cou_name_en": "France",
                  "coordinates": {
                    "lat": 50.05208,
                    "lon": 2.14067
                  },
                  "country_code_2": null,
                  "geoname_id": "2978817",
                  "feature_code": "PPL",
                  "label_en": "France",
                  "dem": 31,
                  "country_code": "FR",
                  "ascii_name": "Saint-Leger-les-Domart",
                  "timezone": "Europe/Paris",
                  "admin2_code": "80",
                  "admin4_code": "80706",
                  "population": 1781
                }
              }
            }
          ]
        }
      },
      "group_by_country-v2.1": {
        "value": {
          "results": [
            {
              "count": 16729,
              "cou_name_en": "United States"
            },
            {
              "count": 9945,
              "cou_name_en": "Italy"
            },
            {
              "count": 8981,
              "cou_name_en": "Mexico"
            }
          ]
        }
      },
      "dataset-v2.1": {
        "value": {
          "dataset_id": "geonames-all-cities-with-a-population-1000",
          "dataset_uid": "da_s2n5ed",
          "attachments": [],
          "has_records": true,
          "data_visible": true,
          "fields": [
            {
              "description": null,
              "label": "Geoname ID",
              "type": "text",
              "name": "geoname_id",
              "annotations": {
                "facetsort": [
                  "-count"
                ],
                "id": []
              }
            },
            {
              "description": null,
              "label": "Name",
              "type": "text",
              "name": "name",
              "annotations": {
                "sortable": []
              }
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "ascii_name",
              "label": "ASCII Name"
            },
            {
              "description": null,
              "label": "Alternate Names",
              "type": "text",
              "name": "alternate_names",
              "annotations": {
                "multivalued": [
                  ","
                ]
              }
            },
            {
              "annotations": {},
              "label": "Feature Class",
              "type": "text",
              "name": "feature_class",
              "description": "see http://www.geonames.org/export/codes.html"
            },
            {
              "annotations": {},
              "label": "Feature Code",
              "type": "text",
              "name": "feature_code",
              "description": "see http://www.geonames.org/export/codes.html"
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "country_code",
              "label": "Country Code"
            },
            {
              "description": null,
              "label": "Country name EN",
              "type": "text",
              "name": "cou_name_en",
              "annotations": {
                "facet": [],
                "facetsort": [
                  "alphanum"
                ],
                "disjunctive": []
              }
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "country_code_2",
              "label": "Country Code 2"
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "admin1_code",
              "label": "Admin1 Code"
            },
            {
              "description": null,
              "label": "Admin2 Code",
              "type": "text",
              "name": "admin2_code",
              "annotations": {
                "facetsort": [
                  "-count"
                ]
              }
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "admin3_code",
              "label": "Admin3 Code"
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "admin4_code",
              "label": "Admin4 Code"
            },
            {
              "annotations": {},
              "description": null,
              "type": "int",
              "name": "population",
              "label": "Population"
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "elevation",
              "label": "Elevation"
            },
            {
              "annotations": {},
              "description": null,
              "type": "int",
              "name": "dem",
              "label": "DIgital Elevation Model"
            },
            {
              "description": null,
              "label": "Timezone",
              "type": "text",
              "name": "timezone",
              "annotations": {
                "facet": [],
                "hierarchical": [
                  "/"
                ]
              }
            },
            {
              "annotations": {},
              "description": null,
              "type": "date",
              "name": "modification_date",
              "label": "Modification date"
            },
            {
              "annotations": {},
              "description": null,
              "type": "text",
              "name": "label_en",
              "label": "LABEL EN"
            },
            {
              "description": null,
              "label": "Coordinates",
              "type": "geo_point_2d",
              "name": "coordinates",
              "annotations": {
                "facetsort": [
                  "-count"
                ]
              }
            }
          ],
          "metas": {
            "default": {
              "records_count": 137611,
              "modified": "2021-06-23T07:50:20+00:00",
              "source_domain_address": null,
              "references": "https://download.geonames.org/export/dump/",
              "keyword": [
                "Geonames",
                "city",
                "world"
              ],
              "source_domain_title": null,
              "geographic_reference": [
                "world"
              ],
              "timezone": null,
              "title": "Geonames - All Cities with a population > 1000",
              "parent_domain": null,
              "theme": [
                "Administration, Government, Public finances, Citizenship"
              ],
              "modified_updates_on_data_change": true,
              "metadata_processed": "2021-06-23T07:50:26.162000+00:00",
              "data_processed": "2021-06-22T08:47:08+00:00",
              "territory": [
                "World"
              ],
              "description": "<p>All cities with a population &gt; 1000 or seats of adm div (ca 80.000)</p><h4>Sources and Contributions</h4><ul><li><strong>Sources</strong> : GeoNames is aggregating over hundred different <a href=\"http://www.geonames.org/data-sources.html\">data sources</a>. \t</li><li><strong>Ambassadors</strong> : <a href=\"http://www.geonames.org/team.html#ambassadors\">GeoNames Ambassadors</a> help in many countries. \t</li><li><strong>Wiki</strong> : A <a href=\"http://www.geonames.org/manual.html\">wiki</a> allows to view the data and quickly fix error and add missing places. \t</li><li><strong>Donations and Sponsoring</strong> : Costs for running GeoNames are covered by <a href=\"http://www.geonames.org/donations.html\">donations and sponsoring</a>.</li></ul><p><b>Enrichment:</b></p><ul><li>add country name</li></ul>",
              "modified_updates_on_metadata_change": false,
              "shared_catalog": null,
              "source_domain": null,
              "attributions": [
                "https://www.geonames.org/about.html"
              ],
              "geographic_area_mode": null,
              "geographic_reference_auto": true,
              "geographic_area": null,
              "publisher": "GeoNames",
              "language": "en",
              "license": "CC BY 4.0",
              "source_dataset": null,
              "metadata_languages": [
                "en"
              ],
              "oauth_scope": null,
              "federated": true,
              "license_url": "https://creativecommons.org/licenses/by/4.0/"
            }
          },
          "features": [
            "geo",
            "analyze",
            "timeserie"
          ]
        }
      },
      "facets": {
        "value": {
          "links": [],
          "facets": [
            {
              "facets": [
                {
                  "count": 68888,
                  "state": "displayed",
                  "name": "Europe",
                  "value": "Europe"
                },
                {
                  "count": 36276,
                  "state": "displayed",
                  "name": "America",
                  "value": "America"
                }
              ],
              "name": "timezone"
            },
            {
              "facets": [
                {
                  "count": 313,
                  "state": "displayed",
                  "name": "Afghanistan",
                  "value": "Afghanistan"
                },
                {
                  "count": 356,
                  "state": "displayed",
                  "name": "Albania",
                  "value": "Albania"
                }
              ],
              "name": "cou_name_en"
            }
          ]
        }
      },
      "attachments": {
        "value": {
          "links": [],
          "attachments": [
            {
              "href": "https://documentation-resources.opendatasoft.com/api/v2/catalog/datasets/geonames-all-cities-with-a-population-1000/attachments/cities1000_zip",
              "metas": {
                "mime-type": "application/zip",
                "title": "cities1000.zip"
              }
            }
          ]
        }
      },
      "record": {
        "value": {
          "links": [],
          "record": {
            "id": "5ce430b62d47a400a495c30345fb6fdfac5550f0",
            "timestamp": "2021-06-23T14:46:05.881Z",
            "size": 190,
            "fields": {
              "timezone": "Europe/Brussels",
              "elevation": null,
              "name": "Fraire",
              "modification_date": "2020-04-05",
              "dem": 238,
              "cou_name_en": "Belgium",
              "feature_class": "P",
              "admin3_code": "93",
              "alternate_names": [
                "Fraire"
              ],
              "coordinates": {
                "lat": 50.26127,
                "lon": 4.5076
              },
              "country_code_2": null,
              "geoname_id": "2798031",
              "feature_code": "PPL",
              "label_en": "Belgium",
              "admin4_code": "93088",
              "country_code": "BE",
              "ascii_name": "Fraire",
              "admin1_code": "WAL",
              "admin2_code": "WNA",
              "population": 1492
            }
          }
        }
      }
    },
    "responses": {
      "bad_request": {
        "description": "Bad Request",
        "content": {
          "application/json; charset=utf-8": {
            "schema": {
              "type": "object",
              "properties": {
                "message": {
                  "type": "string",
                  "minLength": 1
                },
                "error_code": {
                  "type": "string",
                  "minLength": 1
                }
              },
              "required": [
                "message",
                "error_code"
              ]
            },
            "examples": {
              "invalid_odsql": {
                "value": {
                  "message": "ODSQL query is malformed: invalid_function() Clause(s) containing the error(s): select.",
                  "error_code": "ODSQLError"
                }
              }
            }
          }
        }
      },
      "quota": {
        "description": "Too many requests",
        "content": {
          "application/json; charset=utf-8": {
            "schema": {
              "type": "object",
              "properties": {
                "errorcode": {
                  "type": "number"
                },
                "reset_time": {
                  "type": "string",
                  "minLength": 1
                },
                "limit_time_unit": {
                  "type": "string",
                  "minLength": 1
                },
                "call_limit": {
                  "type": "number"
                },
                "error": {
                  "type": "string",
                  "minLength": 1
                }
              },
              "required": [
                "errorcode",
                "reset_time",
                "limit_time_unit",
                "call_limit",
                "error"
              ]
            },
            "examples": {
              "quota_exceeded": {
                "value": {
                  "errorcode": 10002,
                  "reset_time": "2021-01-26T00:00:00Z",
                  "limit_time_unit": "day",
                  "call_limit": 10000,
                  "error": "Too many requests on the domain. Please contact the domain administrator."
                }
              }
            }
          }
        }
      }
    }
  }
}